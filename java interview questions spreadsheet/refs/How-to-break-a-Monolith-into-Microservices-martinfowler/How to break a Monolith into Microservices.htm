<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0072)https://martinfowler.com/articles/break-monolith-into-microservices.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="uft-8" name="charset">

<title>How to break a Monolith into Microservices</title>

<meta content="summary_large_image" name="twitter:card">

<meta content="16665197" name="twitter:site:id">

<meta content="How to break a Monolith into Microservices" property="og:title">

<meta content="https://martinfowler.com/articles/break-monolith-into-microservices.html" property="og:url">

<meta content="A guide to the common steps we&#39;ve observed in breaking a monolithic application up into microservices" property="og:description">

<meta content="https://martinfowler.com/articles/break-monolith-into-microservices/sketch.png" property="og:image">

<meta content="martinfowler.com" property="og:site_name">

<meta content="article" property="og:type">

<meta content="2018-04-24" property="og:article:modified_time">

<meta content="width=device-width, initial-scale=1" name="viewport">

<link href="./How to break a Monolith into Microservices_files/break-monolith-into-microservices.css" rel="stylesheet" type="text/css">
</head>

<body><header id="banner" style="background-image: url(&quot;/banner.png&quot;); background-repeat: no-repeat">

<div class="name-logo"><a href="https://martinfowler.com/"><img src="./How to break a Monolith into Microservices_files/mf-name-white.png"></a></div>
  <div class="search">
    <!-- SiteSearch Google -->
    <form method="GET" action="https://www.google.com/search">
      <input type="hidden" name="ie" value="UTF-8">
      <input type="hidden" name="oe" value="UTF-8">
      <input class="field" type="text" name="q" size="15" maxlength="255" value="">
      <button class="button" type="submit" name="btnG" value=" " title="Search">
      <input type="hidden" name="domains" value="martinfowler.com">
      <input type="hidden" name="sitesearch" value=""> 
      <input type="hidden" name="sitesearch" value="martinfowler.com">
    
  </button></form></div>

<div class="menu-button navmenu-button"><a class="icon icon-bars" href="https://martinfowler.com/articles/break-monolith-into-microservices.html#navmenu-bottom"></a></div>

<nav class="top-menu">
<ul>
<li><a class="" href="https://refactoring.com/">Refactoring</a></li>

<li><a class="" href="https://martinfowler.com/agile.html">Agile</a></li>

<li><a class="" href="https://martinfowler.com/architecture">Architecture</a></li>

<li><a class="" href="https://martinfowler.com/aboutMe.html">About</a></li>

<li><a class="tw" href="https://www.thoughtworks.com/">ThoughtWorks</a></li>

<li><a class="icon icon-rss" href="https://martinfowler.com/feed.atom" title="feed"></a></li>

<li><a class="icon icon-twitter" href="https://www.twitter.com/martinfowler" title="twitter stream"></a></li>
</ul>
</nav>
</header>
<nav id="top-navmenu">
<nav class="navmenu">
<div class="nav-head">  <div class="search">
    <!-- SiteSearch Google -->
    <form method="GET" action="https://www.google.com/search">
      <input type="hidden" name="ie" value="UTF-8">
      <input type="hidden" name="oe" value="UTF-8">
      <input class="field" type="text" name="q" size="15" maxlength="255" value="">
      <button class="button" type="submit" name="btnG" value=" " title="Search">
      <input type="hidden" name="domains" value="martinfowler.com">
      <input type="hidden" name="sitesearch" value=""> 
      <input type="hidden" name="sitesearch" value="martinfowler.com">
    
  </button></form></div>

<div class="closediv">
<span class="close" title="close"></span>
</div>
</div>

<div class="nav-body">
<div class="topics">
<h2>Topics</h2>

<p><a href="https://martinfowler.com/architecture">Architecture</a></p>

<p><a href="https://refactoring.com/">Refactoring</a></p>

<p><a href="https://martinfowler.com/agile.html">Agile</a></p>

<p><a href="https://martinfowler.com/delivery.html">Delivery</a></p>

<p><a href="https://martinfowler.com/microservices">Microservices</a></p>

<p><a href="https://martinfowler.com/data">Data</a></p>

<p><a href="https://martinfowler.com/testing">Testing</a></p>

<p><a href="https://martinfowler.com/dsl.html">DSL</a></p>
</div>

<div class="about">
<h2>about me</h2>

<p><a href="https://martinfowler.com/aboutMe.html">About</a></p>

<p><a href="https://martinfowler.com/books">Books</a></p>

<p><a href="https://martinfowler.com/faq.html">FAQ</a></p>
</div>

<div class="content">
<h2>content</h2>

<p><a href="https://martinfowler.com/videos.html">Videos</a></p>

<p><a href="https://martinfowler.com/tags">Content Index</a></p>

<p><a href="https://martinfowler.com/articles/eurogames">Board Games</a></p>

<p><a href="https://martinfowler.com/photos">Photography</a></p>
</div>

<div class="tw">
<h2>ThoughtWorks</h2>

<p><a href="https://thoughtworks.com/insights">Insights</a></p>

<p><a href="https://thoughtworks.com/careers">Careers</a></p>

<p><a href="https://thoughtworks.com/products">Products</a></p>
</div>

<div class="feeds">
<h2>follow</h2>

<p><a href="https://www.twitter.com/martinfowler">Twitter</a></p>

<p><a href="https://martinfowler.com/feed.atom">RSS</a></p>
</div>
</div>
</nav>
</nav>

<div class="contents dropdown-container">
<button class="dropdown-button">
<h2>Contents</h2>
</button>

<div class="hidden" id="dropdownLinks"><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#TheMicroserviceEcosystemDestination">The Microservice Ecosystem Destination</a><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#TheJourneyGuide">The Journey Guide</a>
<ul>
<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#WarmUpWithASimpleAndFairlyDecoupledCapability">Warm Up with a Simple and Fairly Decoupled Capability</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#MinimizeDependencyBackToTheMonolith">Minimize Dependency Back to the Monolith</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#SplitStickyCapabilitiesEarly">Split Sticky Capabilities Early</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#DecoupleVerticallyAndReleaseTheDataEarly">Decouple Vertically and Release the Data Early</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#DecoupleWhatIsImportantToTheBusinessAndChangesFrequently">Decouple What is Important to the Business and Changes Frequently</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#DecoupleCapabilityAndNotCode">Decouple Capability and not Code</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#GoMacroFirstThenMicro">Go Macro First, then Micro</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#MigrateInAtomicEvolutionarySteps">Migrate in Atomic Evolutionary Steps</a></li>
</ul>
</div>
</div>

<main>
<h1>How to break a Monolith into Microservices</h1>

<p class="subtitle">What to decouple and when</p>

<p class="abstract"><i>As monolithic systems become too large to deal with, many
  enterprises are drawn to breaking them down into the microservices
  architectural style. It is a worthwhile journey, but not an easy one. We've
  learned that to do this well, we need to start with a simple service, but then
  draw out services that are based on vertical capabilities that are important
  to the business and subject to frequent change. These services should be large
  at first and preferably not dependent upon the remaining monolith. We should
  ensure that each step of migration represents an atomic improvement to the
  overall architecture.</i></p>

<p class="date">24 April 2018</p>

<div class="frontMatter">
<div class="frontLeft">
<div class="author"><a href="https://twitter.com/zhamakd"><img alt="Photo of Zhamak Dehghani" src="./How to break a Monolith into Microservices_files/zhamak.jpg" width="80"></a>
<p class="name"><a href="https://twitter.com/zhamakd">Zhamak Dehghani</a></p>

<div class="bio">
<p>Zhamak is a principal technology consultant at ThoughtWorks
            with a focus on distributed systems architecture and
            digital platform strategy at Enterprise.
            She is a member of ThoughtWorks Technology Advisory Board
            and contributes to the creation of ThoughtWorks Technology
            Radar.</p>
</div>
</div>

<div class="clear"></div>

<div class="tags">
<p class="tag-link"><a href="https://martinfowler.com/tags/microservices.html">microservices</a></p>
</div>
</div>

<div class="frontRight">
<div class="contents">
<h2>Contents</h2>

<ul>
<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#TheMicroserviceEcosystemDestination">The Microservice Ecosystem Destination</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#TheJourneyGuide">The Journey Guide</a>
<ul>
<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#WarmUpWithASimpleAndFairlyDecoupledCapability">Warm Up with a Simple and Fairly Decoupled Capability</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#MinimizeDependencyBackToTheMonolith">Minimize Dependency Back to the Monolith</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#SplitStickyCapabilitiesEarly">Split Sticky Capabilities Early</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#DecoupleVerticallyAndReleaseTheDataEarly">Decouple Vertically and Release the Data Early</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#DecoupleWhatIsImportantToTheBusinessAndChangesFrequently">Decouple What is Important to the Business and Changes Frequently</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#DecoupleCapabilityAndNotCode">Decouple Capability and not Code</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#GoMacroFirstThenMicro">Go Macro First, then Micro</a></li>

<li><a href="https://martinfowler.com/articles/break-monolith-into-microservices.html#MigrateInAtomicEvolutionarySteps">Migrate in Atomic Evolutionary Steps</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div class="paperBody deep">
<p>Migrating a monolithic system to an <a href="https://martinfowler.com/articles/microservices.html">ecosystem of
    microservices</a> is an epic journey. The ones who embark on this journey
    have aspirations such as increasing the scale of operation, accelerating
    the pace of change and escaping the high cost of change.
    They want to grow their number of teams while enabling them to deliver value
    in parallel and independently of each other. They want to rapidly experiment
    with their business's core capabilities and deliver value faster.
    They also want to escape the high cost associated with making changes to their
    existing monolithic systems.</p>

<p>Deciding what capability to decouple when and how to migrate incrementally 
    are some of the architectural challenges of decomposing a monolith to an 
    ecosystem of microservices. In this write-up, I share a few
    techniques that can guide the delivery teams - developers, architects, technical managers - to make these
    decomposition decisions along the journey.</p>

<p>To clarify the techniques I use a multitier online retail
    application. This application tightly couples user facing, business logic and
    data layer. The reason I have chosen this example is that its architecture 
    has the characteristics of monolithic applications that many businesses run and
    its technology stack is modern enough to justify decomposition instead of a
    complete rewrite and replacement.</p>

<section id="TheMicroserviceEcosystemDestination">
<h2>The Microservice Ecosystem Destination</h2>

<p>Before embarking, it is critical that everyone has a common understanding of
      a <a href="https://martinfowler.com/articles/microservices.html">microservices ecosystem</a>.
      Microservices ecosystem is a platform of services each encapsulating a
      business capability. A business capability represents what a business does in a
      particular domain to fulfill its objectives and responsibilities.
      Each microservice expose an API that developers can discover and use in a
      self-serve manner. Microservices have independent lifecycle. Developers
      can build, test and release each microservice independently. The
      microservices ecosystem enforces an organizational structure of autonomous
      long standing teams, each responsible for one or multiple services.
      Contrary to general perception and ‘micro’ in microservices, the size of
      each service matters least and may vary depending on the operational
      maturity of the organization. As Martin Fowler puts it, 
      "microservices is a label and not the description".</p>

<div class="figure " id="ecosystem.svg" style="width: 750px;"><img class="full-size" src="./How to break a Monolith into Microservices_files/ecosystem.svg" width="750">
<p class="photoCaption">Figure 1: Services encapsulate business
      capabilities, expose data and functionality through self-serve
      APIs</p>
</div>

<div class="clear"></div>
</section>

<section id="TheJourneyGuide">
<h2>The Journey Guide</h2>

<p>Before diving into the guide, it is important to know that there is
      a high overall cost associated with decomposing an existing system to
      microservices and it may take many iterations. It is necessary for developers
      and architects to closely evaluate whether the decomposition of an existing
      monolith is the right path, and whether the microservices itself is the 
      <a href="https://martinfowler.com/articles/microservice-trade-offs.html">right destination</a>.
      Having cleared that out, let’s go through the guide.</p>

<section id="WarmUpWithASimpleAndFairlyDecoupledCapability">
<h3>Warm Up with a Simple and Fairly Decoupled Capability</h3>

<p>Starting down a microservices path requires a minimum level of
        operational readiness. It requires on demand access to deployment
        environment, building new kinds of continuous delivery pipelines to
        independently build, test, and deploy executable services, and the
        ability to secure, debug and monitor a distributed architecture.
        Operational readiness maturity is required whether we are building
        greenfield services or decomposing an existing system.
        For more on this operational readiness see Martin Fowler’s article on
        <a href="https://martinfowler.com/bliki/MicroservicePrerequisites.html">Microservices prerequisites</a>.
        The good news is that since Martin’s article, the technology to operate
        a microservices architecture has evolved rapidly.
        This includes creation of <a href="https://www.thoughtworks.com/radar/techniques/service-mesh">Service Mesh</a>, a dedicated
        infrastructure layer to run fast, reliable and secure network of microservices,
        <a href="https://www.thoughtworks.com/radar/platforms/kubernetes"> container orchestration systems</a> to
        provide a higher level of deployment infrastructure abstraction, and 
        evolution of continuous delivery systems such as <a href="https://www.gocd.org/kubernetes/?gclid=EAIaIQobChMIwu-o1_3E2gIVjcVkCh3XUAkoEAAYASAAEgJPQ_D_BwE">GoCD</a>
        to build, test and deploy microservices as containers.</p>

<p> My suggestion is for developers and operation teams to build out the
        underlying infrastructure, continuous delivery pipelines and the API management
        system with the first and second service that they decompose or build
        new. Start with capabilities that are fairly decoupled from the
        monolith, they don’t require changes to many client facing applications
        that are currently using the monolith and possibly don’t need a data
        store. What the delivery teams are optimizing for at the point is validating their
        delivery approaches, upskilling the team members, and building out minimum
        infrastructure needed to deliver independently deployable secure services
        that expose self-serve APIs. As an example, for an online retail
        application, the first service can be the ‘end user authentication’
        service that the monolith could call to authenticate the end users, and
        the second service could be the ‘customer profile’ service, a facade
        service providing a better view of the customers for new client applications.</p>

<p>First I recommended decoupling simple edge services.
        Next we take a different approach decoupling capabilities deeply embedded in the
        monolithic system. I advise doing edge services first because at the
        beginning of the journey, the delivery teams' biggest risk is failing to operate the
        microservices properly. So it’s good to use the edge services to
        practice the <a href="https://martinfowler.com/bliki/MicroservicePrerequisites.html">operational prerequisites</a>
        they need. Once they have addressed that, they can then address the 
        key problem of splitting the monolith.</p>

<div class="figure " id="warming-up.svg"><img src="./How to break a Monolith into Microservices_files/warming-up.svg">
<p class="photoCaption">Figure 2: Warming up with a simple capability that has a
        small radius of change to build our operational readiness</p>
</div>

<div class="clear"></div>
</section>

<section id="MinimizeDependencyBackToTheMonolith">
<h3>Minimize Dependency Back to the Monolith</h3>

<p>As a founding principle the delivery teams need to minimize the dependencies
        of newly formed microservices to the monolith. A major benefit of
        microservices is to have a fast and independent release cycle. Having
        dependencies to the monolith - data, logic, APIs - couples the service 
        to the monolith's release cycle, prohibiting this benefit.
        Often the main motivation for moving away from the
        monolith is the high cost and slow pace of change of the capabilities locked
        in it, so we want to progressively move in a direction that decouples
        these core capabilities by removing dependencies to the monolith. If
        the teams follow this guideline as they build out capabilities into their own
        services, what they find is instead, dependencies in the reverse direction,
        from the monolith to the services.
        This is a desired dependency direction as it does not slow
        down the pace of change for new services.</p>

<p>Consider in a retail online system, where ‘buy’ and ‘promotions’
        are core capabilities. ‘buy’ uses ‘promotions’ during the checkout process 
        to offer the customers the best promotions that they qualify for,
        given the items they are buying. If we need to decide
        which of these two capabilities to decouple next, I suggest to start with
        decoupling ‘promotions’ first and then 'buy'.
        Because in this order we reduce the dependencies back to the monolith.
        In this order ‘buy’ first remains locked in the monolith with a dependency out to the new
        ‘promotions’ microservice. </p>

<p>Next guidelines offer other ways for deciding the order in which developers decouple services. This means
        that they may not be always able to avoid dependencies back to the monolith.
        In cases where a new service ends up with a call back to the monolith, I suggest to expose a new API from
        the monolith, and access the API through an <a href="https://martinfowler.com/articles/refactoring-external-service.html#SeparatingTheYoutubeDataStructureIntoAGateway">anti-corruption</a> layer in
        the new service to make sure that the monolith concepts do not leak out.
        Strive to define the API reflecting the well defined
        domain concepts and structures, even though the monolith’s internal
        implementation might be otherwise. In this unfortunate case the delivery teams will be
        bearing the cost and difficulty of changing the monolith, testing
        and releasing the new services coupled with the monolith release. </p>

<div class="figure " id="preferred-dependency.svg"><img src="./How to break a Monolith into Microservices_files/preferred-dependency.svg">
<p class="photoCaption">Figure 3: Decouple the service that
        doesn’t require a dependency back to the monolith first and minimize changes
        to the monolith</p>
</div>

<div class="clear"></div>
</section>

<section id="SplitStickyCapabilitiesEarly">
<h3>Split Sticky Capabilities Early</h3>

<p>I am assuming that at this point the delivery teams are comfortable with building
        microservices and ready to attack the sticky problems. However they may find
        themselves limited with the capabilities that they can decouple next
        without a dependency back to the monolith. The root cause of this, is
        often a capability within the monolith that is leaky, not well defined
        as a domain concept, with many of the monolith capabilities depending on
        it. In order to be able to progress, the developers need to identify the sticky
        capability, deconstruct it into well defined domain concepts and then
        <a href="https://en.wikipedia.org/wiki/Reification">reify</a> those domain concepts into separate services. </p>

<p>For example in a web based monolith, the notion of ‘(web) session’ is
        one of those most common coupling factors. In the online retail example, the
        session is often a bucket for many attributes ranging from user
        preferences across different domain boundaries such as shipping
        and payment preferences, to user intentions and interactions
        such as recently visited pages, clicked products, and wish list. Unless
        we tackle decoupling, deconstructing and reifying the current notion of
        ‘session’, we will struggle to decouple many of the future capabilities
        as they will be entangled with the monolith through the leaky session
        concepts. I also discourage creating a ‘session’ service
        outside of the monolith, as it will just result in a similar tight
        coupling that currently exist within the monolith process, only worse,
        out of process and across the network.</p>

<p>Developers can incrementally extract microservices from the sticky capability,
        one service at time. As an example, refactor 'customer wish list' first and extract
        that into a new service, then refactor 'customer payment preferences' into 
        another microservice and repeat.</p>

<div class="figure " id="decouple-most.svg"><img src="./How to break a Monolith into Microservices_files/decouple-most.svg">
<p class="photoCaption">Figure 4: Identify the most coupling concept and
        decouple, deconstruct and reify into concrete domain services</p>
</div>

<div class="clear"></div>

<div class="tip">
<div class="bullet"><img src="./How to break a Monolith into Microservices_files/tip-graphic.png"></div>

<div class="content">Use dependency and structural code analysis tools such as
        <a href="http://structure101.com/">Structure101</a> to identify the most
        coupling and constraining factor capabilities in the monolith.</div>

<div class="clear"></div>
</div>
</section>

<section id="DecoupleVerticallyAndReleaseTheDataEarly">
<h3>Decouple Vertically and Release the Data Early</h3>

<p>The main driver for decoupling capabilities out of a monolith is to
        be able to release them independently. This first
        principle should guide every decision that developers make around how to perform the
        decoupling. A monolithic system often is composed of tightly integrated
        layers or even multiple systems that need to be released together and
        have brittle interdependencies. For example, in an online retail system, the
        monolith composed of one or multiple customer facing online
        shopping applications, a back-end system implementing many of the business
        capabilities with a centrally integrated data store to hold state.</p>

<p>Most decoupling attempts start with extracting the user facing
        components and a few facade services to provide developer friendly APIs
        for the modern UIs, while the data remains locked in one schema and
        storage system. Though this approach gives some quick wins such as changing
        the UI more frequently, when it comes to core capabilities the delivery teams can only
        move as fast as the slowest part, the monolith and its monolithic data
        store. Simply put, without decoupling the data, the architecture is not 
        microservices. Keeping all the data in the same data store is counter to the
        <a href="https://martinfowler.com/articles/microservices.html#DecentralizedDataManagement">Decentralized Data Management</a>
        characteristic of microservices.</p>

<p>The strategy is to move out capabilities vertically, decouple
        the core capability with its data and redirect all front-end
        applications to the new APIs.</p>

<p>Having multiple applications writing and reading to and from the centrally shared
        data is the main blocker to decoupling the data along with the service.
        The delivery teams need to incorporate a data migration strategy that suits their
        environment depending on whether they are able to redirect and migrate
        all the data readers/writers at the same time or not. Stripe’s 
        <a href="https://robertheaton.com/2015/08/31/migrating-bajillions-of-database-records-at-stripe">four phase data migration strategy</a>
        is one that applies to many environments
        that require to incrementally migrate the applications that integrate through the database,
        while all the systems under change need to run continuously.</p>

<div class="figure " id="decouple-capability.svg"><img src="./How to break a Monolith into Microservices_files/decouple-capability.svg">
<p class="photoCaption">Figure 5: Decouple capability with its data
        to a microservice exposing a new interface, modify and redirect
        consumers to the new API </p>
</div>

<div class="clear"></div>

<div class="tip">
<div class="bullet"><img src="./How to break a Monolith into Microservices_files/tip-graphic.png"></div>

<div class="content">Avoid the anti pattern of only decoupling facades, only decoupling the
        backend service and never decoupling data.</div>

<div class="clear"></div>
</div>
</section>

<section id="DecoupleWhatIsImportantToTheBusinessAndChangesFrequently">
<h3>Decouple What is Important to the Business and Changes Frequently</h3>

<p>Decoupling capabilities from the monolith is hard. I’ve heard
        <a href="http://nealford.com/">Neal Ford</a> use the analogy of a
        careful organ surgery. In the online retail application, extracting
        a capability involves carefully extracting the capability’s data, logic,
        user facing components and redirecting them to the new service.
        Because this is a non-trivial amount of work, the developers need to
        continuously evaluate the cost of decoupling against the benefits
        that they get, e.g. going faster or growing in scale. For example, if the
        delivery teams' objective is to accelerate the modifications to existing capabilities
        locked in a monolith, then they must identify the capability that is being modified the
        most to take out. Decouple parts of the code that are continuously undergoing
        change and getting a lot of love from the developers and are
        constraining them most to deliver value fast. The delivery teams can analyse the code
        commit patterns to find out what has historically changed most, and 
        overlay that with the product roadmap and portfolio to
        understand the most desired capabilities that will be getting attention
        in near future. They need to talk to the business and product managers to understand
        the differentiating capabilities that really matter to them.</p>

<p>For example in an online retail system, ‘customer personalization’ is
        a capability that goes under a lot of experimentation to provide the
        best experience to the customer and is a good candidate for decoupling.
        It is a capability that matters to business a lot, customer experience,
        and gets modified frequently.</p>

<div class="figure " id="matters-most.svg"><img src="./How to break a Monolith into Microservices_files/matters-most.svg">
<p class="photoCaption">Figure 6: Identify and decouple the capability that
        matters most: creates most value for business and customer, while
        changing regularly.</p>
</div>

<div class="clear"></div>

<div class="tip">
<div class="bullet"><img src="./How to break a Monolith into Microservices_files/tip-graphic.png"></div>

<div class="content">Use <a href="https://www.thoughtworks.com/radar/techniques/social-code-analysis">social code analysis</a>
        tools such as <a href="https://www.empear.com/">CodeScene</a> to find the most
        lively components. Make sure to filter signal from the noise if the
        build system happens to touch or auto-generate code on every commit.
        Overlay the frequently changed code  with the product roadmap upcoming changes and
        find the intersection to decouple.</div>

<div class="clear"></div>
</div>
</section>

<section id="DecoupleCapabilityAndNotCode">
<h3>Decouple Capability and not Code</h3>

<p>Whenever developers want to extract a service out of an existing system, they
        have two ways to go about it: extract code or rewrite capability.</p>

<p>Often by default the service extraction or monolith decomposition is
        imagined as a case of reusing the existing implementation as-is and
        extracting it into a separate service. Partly because we have a
        cognitive bias towards the code we design and write. The labor of
        building, no matter how painful the process or imperfect the result,
        make us grow love for it. This is in fact known as the
        <a href="https://en.wikipedia.org/wiki/IKEA_effect">IKEA Effect</a>.
        Unfortunately this bias is going to hold the monolith decomposition effort back.
        It causes the developers and more importantly technical managers to
        disregard the high cost and low value of extracting and reusing the code.</p>

<p>Alternatively the delivery teams have the option of rewriting the capability and
        retiring the old code. The rewrite gives them an opportunity to revisit
        the business capability, initiate a conversation with the business to
        simplify the legacy process and challenge the old assumption and
        constraints built over time into the system. It also provides an
        opportunity for a technology refresh, implementing the new service with
        a programming language and technology stack that is most suitable for
        that particular service.</p>

<p>For example in the retail system, the ‘pricing and promotion’
        capability is an intellectually complex piece of code. It enables
        dynamic configuration and application of pricing and promotion rules,
        providing discounts and offers based on a variety of parameters such as
        customer behavior, loyalty, product bundles, etc.</p>

<p>This capability is arguably a good candidate for reuse and
        extraction. In contrast, ‘customer profile’ is a simple
        <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> capability
        that is mostly composed of boilerplate code for serialization, handling
        storage and configuration, hence, it is a good candidate for rewrite and
        retire.</p>

<p>In my experience, in majority of the decomposition scenarios, the teams are
        better off to rewrite the capability as a new service and retire the old
        code. This is considering the high cost and low value of reuse, due to
        reasons such as below:</p>

<ul>
<li>There is a large amount of boilerplate code that deals with
          environmental dependencies, such as accessing application configuration
          at runtime, accessing data stores, caching, and is built with old
          frameworks. Most of this boilerplate code needs to be rewritten. The new
          infrastructure to host a microservice is very different from the decades
          old application runtime and will require a very different kind of
          boilerplate code.</li>

<li>It is very likely that the existing capabilities are not built around
          clear domain concepts. This results in transporting or storing data
          structures that are not reflecting the new domain models and require
          undergoing a big restructuring.</li>

<li>A long lived legacy code that has gone through many iterations of
          change could have a high <a href="https://erik.doernenburg.com/2008/11/how-toxic-is-your-code">code toxicity</a>
          level and low value for reuse.</li>
</ul>

<p>Unless the capability is relevant, aligned with a
        clear domain concept and has high intellectual property, I strongly
        recommend a rewrite and retiring of the old code.</p>

<div class="figure " id="reuse-rewrite.svg"><img src="./How to break a Monolith into Microservices_files/reuse-rewrite.svg">
<p class="photoCaption">Figure 7: Reuse and Extract high value code with
        low toxicity, Rewrite and Retire low value code with high
        toxicity</p>
</div>

<div class="clear"></div>

<div class="tip">
<div class="bullet"><img src="./How to break a Monolith into Microservices_files/tip-graphic.png"></div>

<div class="content">Use code toxicity analysis tools such as
        <a href="http://checkstyle.sourceforge.net/">CheckStyle</a> to make decisions around
        rewrite vs. reuse.</div>

<div class="clear"></div>
</div>
</section>

<section id="GoMacroFirstThenMicro">
<h3>Go Macro First, then Micro</h3>

<p>Finding the domain boundaries in a legacy monolith is both an
        art and science. As a general rule applying domain driven design
        techniques to find the <a href="https://martinfowler.com/bliki/BoundedContext.html">bounded contexts</a>
        defining microservices boundaries is a good place to start.
        I admit, far too often I see an overcorrection from large monolith to really
        small services, really small services whose design is inspired and driven
        by the existing normalized view of the data.
        This approach to identifying service boundaries almost always leads to a
        cambrian explosion of large number
        of <a href="https://www.martinfowler.com/bliki/AnemicDomainModel.html">anemic services</a> for CRUD resources.
        For many new to the microservices
        architecture, this creates a high friction environment that ultimately
        fails the test of independent release and execution of the services. It
        creates a distributed system that is hard to debug, a distributed system
        that is broken across transactional boundaries and hence difficult to
        keep consistent, a system that is too complex for the operational
        maturity of the organization. Though there are
        <a href="https://www.youtube.com/watch?v=UfQTNtbq170">some heuristics</a> on how
        ‘micro’ should be the microservice: the size of the team, the time to
        rewrite the service, how much behavior it must encapsulate, etc. My advice is
        that the size depends on how many services the delivery and operation teams
        can independently release,
        monitor and operate. Start with larger services around a logical domain
        concept, and break the service down into multiple services when the teams are
        operationally ready.</p>

<p>For example, on the journey decoupling the retail system, developers may start
        with one service ‘buy’ that encapsulates both the content of a ‘shopping
        bag’ as well as capability of buying the shopping bag, i.e ‘check out’.
        As their ability to form smaller teams and release larger number of services
        grows then they can decouple ‘shopping bag’ from ‘check out’ into a
        separate service. </p>

<div class="figure " id="macro-micro.svg"><img src="./How to break a Monolith into Microservices_files/macro-micro.svg">
<p class="photoCaption">Figure 8: Decouple macro services around rich domain
        concepts and when ready, breakdown services to smaller domain
        concepts</p>
</div>

<div class="clear"></div>

<div class="tip">
<div class="bullet"><img src="./How to break a Monolith into Microservices_files/tip-graphic.png"></div>

<div class="content">Use <a href="https://martinfowler.com/articles/richardsonMaturityModel.html">Richardson Maturity Model L3</a>
        and hyperlinks to enable future decoupling of services without impacting callers,
        i.e. caller discovers how to checkout and does not know in advanced. </div>

<div class="clear"></div>
</div>
</section>

<section id="MigrateInAtomicEvolutionarySteps">
<h3>Migrate in Atomic Evolutionary Steps</h3>

<p>The idea of vanishing a legacy monolith into thin air by decoupling
        it into beautifully designed microservices is somewhat of a myth and
        arguably undesirable. Any seasoned engineer can share stories of legacy
        migration and modernization attempts that got planned and initiated with
        over optimism of total completion, and at best got abandoned at a good
        enough point in time. Long term plans of such endeavors get abandoned
        because the macro conditions change: the program runs out of money, the
        organization pivots its focus to something else or leadership in support
        of it leaves. So this reality should be designed in how the teams approach the
        monolith to microservices journey. I call this approach 'migration in
        atomic steps of architecture evolution', where every step of the
        migration should take the architecture closer to its target state. Each
        unit of evolution might be a small step or a large leap but is atomic,
        either completes or reverts. This is specially important as we are
        taking an iterative and incremental approach to improving the overall
        architecture and decoupling services. Every increment must leave us in
        a better place in terms of the architecture goal. Using the
        <a href="https://www.thoughtworks.com/books/building-evolutionary-architectures">evolutionary architecture</a>
        fitness function metaphor, the architecture fitness function after every
        atomic step of migration should generate a closer value to the
        architecture’s goal.</p>

<p>Let me illustrate this point with an example. Imagine the
        microservice architecture goal is to increase the speed of developers
        modifying the overall system to deliver value. The team decides to
        decouple the end user authentication into a separate service based on
        OAuth 2.0 protocol. This service is intended to both replace how the
        existing (old architecture) client application authenticates the end
        user, as well as new architecture microservices validate the end user.
        Let's call this increment in the evolution, ‘Auth service introduction’.
        One way to introduce the new service is to go through these steps
        first:</p>

<p>(1) Build the Auth service, implementing OAuth 2.0 protocol.</p>

<p>(2) Add a new authentication path in the monolith back end to call
        Auth service for authenticating the end user on whose behalf it is
        processing a request.</p>

<p>If the team stops here and pivots into building some other service or
        feature, they leave the overall architecture in a state of increased
        entropy. In this state there are two ways of authenticating the user, the new OAuth
        2.0 base path, and old client’s password/session based path. At this
        point the teams are actually further away from their overall goal of making
        changes faster. Any new developer to the monolith code needs to deal
        with two code paths, increased cognitive load of understanding the code,
        and slower process of changing and testing it.</p>

<p>Instead the team can include the following steps in our atomic unit of
        evolution:</p>

<p>(3) Replace old client’s password/session based authentication with
        OAuth 2.0 path</p>

<p>(4) Retire the old authentication code path from the monolith</p>

<p>At this point we can argue that the teams have gotten closer to the target
        architecture.</p>

<div class="figure " id="fitness-function.svg"><img src="./How to break a Monolith into Microservices_files/fitness-function.svg">
<p class="photoCaption">Figure 9: Evolve the architecture towards
        microservices with atomic steps of architecture evolution where after
        each step the overall architecture is improved towards its goal even
        though intermediary code changes might take it further away from its
        fitness objective</p>
</div>

<div class="clear"></div>

<div class="tip">
<div class="bullet"><img src="./How to break a Monolith into Microservices_files/tip-graphic.png"></div>

<div class="content">
<p>The atomic unit of monolith decomposition includes:</p>

<ul>
<li>decouple the new service</li>

<li>Redirect all consumers to new service</li>

<li>Retire the old code path in the monolith.</li>
</ul>

<p>The anti-pattern: Decouple the new service, use for new consumers
          and never retire the old.</p>
</div>

<div class="clear"></div>
</div>

<p>I often find teams end migration of a capability out of the monolith
        and claim victory as soon as the new capability is built without
        retiring the old code path, the anti-pattern described above. The main
        reasons for this are (a) the focus on short-term benefits of introducing
        a new capability and (b) the total amount of effort required to retire
        the old implementations while facing competing priorities for building
        new features. In order to do the right thing, we need to strive for
        making the atomic steps as small as possible.</p>

<p>Migrating with this approach we can break up the journey to shorter
        trips. We can safely stop, revive and survive this long journey, slaying the monolith.</p>
</section>
</section>

<hr class="bodySep">
</div>

<div class="appendix">
<h2 id="SignificantRevisions">Significant Revisions</h2>

<p><i>24 April 2018: </i>First published</p>
</div>
</main>

<nav id="bottom-navmenu" style="display: none;">
<nav class="navmenu">
<div class="nav-head">  <div class="search">
    <!-- SiteSearch Google -->
    <form method="GET" action="https://www.google.com/search">
      <input type="hidden" name="ie" value="UTF-8">
      <input type="hidden" name="oe" value="UTF-8">
      <input class="field" type="text" name="q" size="15" maxlength="255" value="">
      <button class="button" type="submit" name="btnG" value=" " title="Search">
      <input type="hidden" name="domains" value="martinfowler.com">
      <input type="hidden" name="sitesearch" value=""> 
      <input type="hidden" name="sitesearch" value="martinfowler.com">
    
  </button></form></div>

<div class="closediv">
<span class="close" title="close"></span>
</div>
</div>

<div class="nav-body">
<div class="topics">
<h2>Topics</h2>

<p><a href="https://martinfowler.com/architecture">Architecture</a></p>

<p><a href="https://refactoring.com/">Refactoring</a></p>

<p><a href="https://martinfowler.com/agile.html">Agile</a></p>

<p><a href="https://martinfowler.com/delivery.html">Delivery</a></p>

<p><a href="https://martinfowler.com/microservices">Microservices</a></p>

<p><a href="https://martinfowler.com/data">Data</a></p>

<p><a href="https://martinfowler.com/testing">Testing</a></p>

<p><a href="https://martinfowler.com/dsl.html">DSL</a></p>
</div>

<div class="about">
<h2>about me</h2>

<p><a href="https://martinfowler.com/aboutMe.html">About</a></p>

<p><a href="https://martinfowler.com/books">Books</a></p>

<p><a href="https://martinfowler.com/faq.html">FAQ</a></p>
</div>

<div class="content">
<h2>content</h2>

<p><a href="https://martinfowler.com/videos.html">Videos</a></p>

<p><a href="https://martinfowler.com/tags">Content Index</a></p>

<p><a href="https://martinfowler.com/articles/eurogames">Board Games</a></p>

<p><a href="https://martinfowler.com/photos">Photography</a></p>
</div>

<div class="tw">
<h2>ThoughtWorks</h2>

<p><a href="https://thoughtworks.com/insights">Insights</a></p>

<p><a href="https://thoughtworks.com/careers">Careers</a></p>

<p><a href="https://thoughtworks.com/products">Products</a></p>
</div>

<div class="feeds">
<h2>follow</h2>

<p><a href="https://www.twitter.com/martinfowler">Twitter</a></p>

<p><a href="https://martinfowler.com/feed.atom">RSS</a></p>
</div>
</div>
</nav>
</nav>
<footer id="page-footer">
<div class="tw-logo">
<a href="http://www.thoughtworks.com/">
<img src="./How to break a Monolith into Microservices_files/tw-white-300.png">
</a>
</div>
<div class="menu-button">
<div class="icon-bars navmenu-button"></div>
</div>
<div class="copyright">
<p>© Martin Fowler | <a href="http://www.thoughtworks.com/privacy-policy">Privacy Policy</a> | <a href="https://martinfowler.com/aboutMe.html#disclosures">Disclosures</a></p>
</div>
</footer>
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-17005812-1', 'auto');
ga('send', 'pageview');
</script>
<script async="" src="./How to break a Monolith into Microservices_files/analytics.js"></script>
<!-- End Google Analytics -->



<script src="./How to break a Monolith into Microservices_files/jquery-1.11.3.min.js" type="text/javascript"></script>

<script src="./How to break a Monolith into Microservices_files/mfcom.js" type="text/javascript"></script>


</body></html>