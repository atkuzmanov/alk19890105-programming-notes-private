<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0043)http://coopsoft.com/ar/CalamityArticle.html -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="HTML Tidy for HTML5 for Windows version 5.1.25">
<meta name="author" content="E. P. Harned">
<meta name="description" content="A Java Fork-Join Calamity">
<meta name="keywords" content="java, edward harned, threads, fork join, multi-core, multi threading, concurrency">

<meta name="ROBOTS" content="index, follow">
<meta name="viewport" content="width = device-width">
<title>A Java Fork-Join Calamity</title>
</head>
<body>
<p align="center"><span class="atitle"><strong><font face="Arial, Helvetica" size="5">A Java</font><sup><font face="Arial" size="4">?</font></sup> <font face="Arial, Helvetica" size="5">Fork-Join Calamity</font></strong></span></p>
<h3 align="center"><span class="atitle"><strong><font face="Arial, Helvetica" size="3">Parallel processing with
multi-core</font></strong></span> <font face="Arial" size="3">Java?</font> <span class="atitle"><strong><font face="Arial, Helvetica" size="3">applications</font></strong></span></h3>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Included in the
new Java? SE 7 release is a so-called lightweight Fork-Join
framework. When you take a careful, comprehensive look at what this
framework does and how it does it, then you will see that the
framework is an inadequate academic experiment underpinning a
research paper, not a lightweight framework.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">This article
explains why (5500 words) [yes, it's getting loooong]</font></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2"><a href="http://coopsoft.com/ar/CalamityArticle.html#author">Edward Harned</a> (<a href="mailto:eh%20at%20coopsoft%20dot%20com">eh at coopsoft dot
com</a>)<br>
Senior Developer, Cooperative Software Systems, Inc.<br>
January, 2011&nbsp; [updated July, 2016]</font></p>
<h3><font face="Arial, Helvetica">What is the Lightweight Fork-Join
framework?</font></h3>
<p><font face="Verdana, Arial, Helvetica" size="2">The lightweight
Fork/Join (F/J) framework is a structure that supports parallel
programming where problems are recursively split into smaller
parts, solved in parallel and recombined, as described in this
pseudo code from <a href="http://coopsoft.com/ar/CalamityArticle.html#references">A Java Fork/Join
Framework</a>:<br>
&nbsp;</font></p>
<blockquote>
<table bgcolor="#CCCCCC" border="1" cellpadding="5" cellspacing="0" width="502" style="border-collapse: collapse" summary="Fork-Join Processing">
<tbody><tr>
<td style="font-family: Verdana" height="8" width="488" align="center">
<p align="left"><font size="2">&nbsp;&nbsp;</font> <font size="2">Result solve(Problem problem) {</font></p>
<p align="left"><font size="2" color="#7F0055"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if</b></font>
<font size="2">(problem is small)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; directly solve
problem<br></font><font size="2" color="#7F0055"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</b></font>
<font size="2">{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; split problem into
independent
parts<u><br></u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fork</font> <font size="2" color="#7F0055"><b>new</b></font>
<font size="2">subtasks to solve each
part<u><br></u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; join
all subtasks<u><br></u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
compose result from subresults<u><br></u>&nbsp;&nbsp;&nbsp;
}<br>
}</font></p>
</td>
</tr>
</tbody></table>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">If only the real
solution were this simple. In order to make this work, the
framework developer would have to build a parallel engine inside
the Java? Virtual Machine by ripping apart the current JDK source
code, compilers, hotspot, various run times, and implementations —
not a likely scenario. Hence, the only practical solution is to
build an application server.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">If only the
lightweight F/J Framework were a blue-ribbon application server.
Regrettably, the framework is not a professional application
server. It is not even an API. The framework is the academic
experiment for the <a href="http://coopsoft.com/ar/CalamityArticle.html#references">Java Fork/Join
Framework</a> research paper. It is inadequate, not
lightweight.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2"><a href="http://coopsoft.com/ar/CalamityArticle.html#references">Part two</a> of this series added in January, 2013,
deals with the problems of making this framework the default
parallel engine for bulk operations in JDK1.8.</font></p>
<blockquote>
<blockquote>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">These articles
are getting too lengthy for comfortable reading since they contain
the details to support each point. Here is a <a href="http://coopsoft.com/dl/Blunder.pdf">downloadable consolidation</a>
in PDF format that uses the articles points as references. Much
easier to digest.</font></p>
</blockquote>
</blockquote>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2"><a href="http://coopsoft.com/ar/CalamityArticle.html#references">Part three</a> of this series added in January, 2014,
deals with the failure to improve the performance of parallel
operations.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">The F/J
framework simply does not belong inside the JDK. The remainder of
this article is a critique <u>only</u> as it applies to to the
framework being part of Standard Edition Java?.</font></p>
<h3><font face="Arial, Helvetica">Critique</font></h3>
<p><font face="Verdana, Arial, Helvetica" size="2">There are major
impediments for this framework being part of the JDK. The F/J
framework is:</font></p>
<ol>
<li><a href="http://coopsoft.com/ar/CalamityArticle.html#faulty"><font face="Verdana, Arial, Helvetica" size="2">a faulty task manager</font></a></li>
<li><a href="http://coopsoft.com/ar/CalamityArticle.html#inefficient"><font face="Verdana, Arial, Helvetica" size="2">inefficient</font></a></li>
<li><a href="http://coopsoft.com/ar/CalamityArticle.html#special"><font face="Verdana, Arial, Helvetica" size="2">special purpose</font></a></li>
<li><a href="http://coopsoft.com/ar/CalamityArticle.html#slow"><font face="Verdana, Arial, Helvetica" size="2">slow and unscalable</font></a></li>
<li><a href="http://coopsoft.com/ar/CalamityArticle.html#complex"><font face="Verdana, Arial, Helvetica" size="2">exceedingly complex</font></a></li>
<li><a href="http://coopsoft.com/ar/CalamityArticle.html#attrb"><font face="Verdana, Arial, Helvetica" size="2">lacking in professional attributes</font></a></li>
<li><a href="http://coopsoft.com/ar/CalamityArticle.html#academic"><font face="Verdana, Arial, Helvetica" size="2">an academic exercise</font></a></li>
<li><a href="http://coopsoft.com/ar/CalamityArticle.html#lacking"><font face="Verdana, Arial, Helvetica" size="2">inadequate in scope</font></a></li>
<li><a href="http://coopsoft.com/ar/CalamityArticle.html#Not"><font face="Verdana, Arial, Helvetica" size="2">not an API</font></a></li>
</ol>
<p><font face="Verdana, Arial, Helvetica" size="2"><a href="http://coopsoft.com/ar/CalamityArticle.html#conclu">Conclusion</a>.</font></p>
<h3><font face="Arial, Helvetica"><a name="faulty" id="faulty"></a>A Faulty Task Manager</font></h3>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">The Fork-Join
technique splits the work into fragments and joins the results
together. A subordinate practice that allows an intermediate join()
for each fork() can only work successfully in a controlled
environment.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">A fatal flaw
with the F/J Framework is that it is trying to manage an
intermediate join() in a task outside of a controlled environment.
Only the Operating System (O/S) or a pseudo O/S can manage an
intermediate join() in a task. (Whether they’re called tasks or
processes is all the same thing.)</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Briefly: When a
task requires a resource or service (memory, file handle, join())
it goes to the O/S, the ultimate controlled environment. If the
request will put the running task in a waiting state, the O/S
switches the task context to the suspended queue and switches in a
new task context from the active queue for the processor to
execute.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">An Application
Task Manager (pseudo O/S) like <a href="http://coopsoft.com/ar/CalamityArticle.html#references">Cilk</a> or
<a href="http://coopsoft.com/ar/CalamityArticle.html#references">jCilk</a> can only work when the application
goes through <b>it</b> (using a compiler and runtime that creates a
controlled environment) to request resources or services like
join(). That way the manager knows to switch out/in on pseudo
processors it controls.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Basic
application frameworks simply have no way of knowing the
application execution environment therefore, there is no way on
this great, green earth an application framework can do a context
switch to support an intermediate join().</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2"><a name="greater" id="greater"></a>The F/J Framework’s JDK1.7 answer to an
intermediate join() without a context switch is “continuation
threads.” That is, the framework creates additional, temporary
threads to continue fetching application tasks from the deques and
submission queue while the joining thread enters a wait state. That
can result in a huge number of threads for each request.
(StackOverflow has one report of over <a href="http://coopsoft.com/ar/CalamityArticle.html#references">700
continuation threads</a> needed to complete one call.)&nbsp; — An
unmitigated failure.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">The F/J
Framework’s JDK1.8 answer to an intermediate join() without a
context switch is “continuation fetching.” That is, the framework
marks the joining task as logically waiting and the thread
continues fetching and executing tasks from the deque. That can
result in a stall (thread in a wait state) when the recursion level
becomes long. The proof is in the profiler. (You can download the
source code for MultiRecurSubmit.java demo <a href="http://coopsoft.com/ar/CalamityArticle.html#references">below</a>.)</font></p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Additionally,
there is the problem of errors/exceptions in subsequently fetched
tasks.</font></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">Since the stack
holds the entire flow, can the F/J Framework handle stack-overflow
problems?</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">Can the F/J
Framework find the stack entries for the first joining task, or the
second, or the third for error recovery?</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">Can the F/J
Framework back out and recover other associated tasks in other
deques?</font></li>
</ul>
<p><font face="Verdana, Arial, Helvetica" size="2">The answer is
<b>no</b> to all of the above.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Let's not forget
the asynchronous use of outside resources by tasks. Often a
resource will associate a request with the thread that made the
request:<br>
&nbsp;&nbsp;&nbsp; Thread caller =
Thread.currentThread();</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">When the first
tasks does a fork-join while the asynchronous call proceeds, the
same thread will execute the forked task. If that new task
fails,</font></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">what happens to
the asynchronous request to the outside resource since they're both
associated with the same thread?</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">What happens to
handles, and registers, and memory since there is no clean break
(context switch) between tasks?</font></li>
</ul>
<p><font face="Verdana, Arial, Helvetica" size="2">The answer is
<b>uncertainty</b> to all of the above.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">The F/J
Framework’s current handling of tasks for JDK1.8 is an unmitigated
failure. Soon to come is the Lambda-fication of the framework that
should prove interesting, but unsuccessful.</font></p>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">The intermediate
join() isn't the only source of excessive thread creation with this
framework.</font></p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Introduced with
JDK1.7 is the Phaser Class. To quote the JavaDoc:</font></p>
<blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face="Verdana, Arial, Helvetica" size="2">“Phasers may be tiered (i.e., constructed in tree structures)
to reduce contention. Phasers with large numbers of parties that
would otherwise experience heavy synchronization contention costs
may instead be set up so that groups of sub-phasers share a common
parent.”</font></p>
</blockquote>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Not mentioned in
the JavaDoc is that when using a large number of parties the
framework creates “compensation threads” to continue fetching
application tasks from the deques and submission queue while each
original thread waits for sub-phasers to arrive. These
“compensation threads” can be so excessive they make the
“continuation threads” problem, above, seem meek. See for yourself.
(You can download the source code for TieredPhaser.java demo
<a href="http://coopsoft.com/ar/CalamityArticle.html#references">below</a>.)</font></p>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Introduced with
JDK1.8 is the CompletableFuture Class. To quote the
JavaDoc:</font></p>
<blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face="Verdana, Arial, Helvetica" size="2">“A Future that may be explicitly completed (setting its value
and status), and may include dependent functions and actions that
trigger upon its completion.”</font></p>
</blockquote>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Not mentioned in
the JavaDoc is that when using a large number of dependent
functions with a get() method, the framework creates “compensation
threads” to continue fetching application tasks from the deques and
submission queue. Once again, these “compensation threads” can be
so excessive they make the “continuation threads” problem, above,
seem meek. See for yourself. (You can download the source code for
MultiCompletables.java demo <a href="http://coopsoft.com/ar/CalamityArticle.html#references">below</a>.)</font></p>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">The problem is
tasks needing to wait. When a task needs to wait for <u>any</u>
resource, the framework must detach the task from the thread. This
framework cannot detach the task from the thread so it tries other
means again and again and again.</font></p>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Patching the F/J
Framework repeatedly is like playing whack-a-mole. There always
comes a time when no amount of patching will work since it never
addresses the fundamental flaw —</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Any wait without
a context switch is an absolute, total, complete
failure.</font></p>
<p><b><font face="Verdana, Arial, Helvetica" size="2">Is there an
alternative? Certainly.</font></b></p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Using a separate
structure to hold intermediate results rather then using an
intermediate join() is a simple alternative and it has commendable
benefits:</font></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">It doesn’t
require the horrendous complexity of Task Management.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It can easily
support cyclic dependencies.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It can easily
handle synchronous and asynchronous completion
processing.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It
provides</font>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">a way to track
the request throughout it’s lifetime to aid in error
detection/recovery.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">the ability to
time and cancel requests.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">the capability
to gather statistics for tuning.</font></li>
</ul>
</li>
</ul>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">The faulty F/J
Framework has no place within the JDK.</font></p>
</blockquote>
<h3><font face="Arial, Helvetica"><a name="inefficient" id="inefficient"></a>Inefficient</font></h3>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Assume a
java.util.concurrent.RecursiveTask that sums a long array in the
compute() method.</font></p>
<blockquote>
<blockquote>
<table bgcolor="#CCCCCC" border="1" cellpadding="5" cellspacing="0" width="358" style="border-collapse: collapse" summary="Fork-Join Processing">
<tbody><tr>
<td style="font-family: Verdana" height="8" width="344" align="center">
<p align="left"><font size="2">Sum</font> <font size="2" color="#0000C0">left</font><font size="2">&nbsp;&nbsp; =</font>
<font size="2" color="#7F0055"><b>new</b></font> <font size="2">Sum(array, low, mid);<u><br></u> Sum</font> <font size="2" color="#0000C0">right</font> <font size="2">=</font> <font size="2" color="#7F0055"><b>new</b></font> <font size="2">Sum(array, mid,
high);<br>
<br></font> <font size="2" color="#0000C0">left</font><font size="2">.fork();<br></font> <font size="2" color="#7F0055"><b>long</b></font> <font size="2">rightAns =</font>
<font size="2" color="#0000C0">right</font><font size="2">.compute();<br></font> <font size="2" color="#7F0055"><b>long</b></font> <font size="2">leftAns&nbsp;&nbsp;
=</font> <font size="2" color="#0000C0">left</font><font size="2">.join(); <u><br>
<br></u></font> <font size="2" color="#7F0055"><b>return</b></font> <font size="2">leftAns +
rightAns;</font></p>
</td>
</tr>
</tbody></table>
</blockquote>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">At level 1, we
split the array creating two new Tasks for the next level. We issue
a fork() for the left and compute() for the right. The fork() adds
a Task to the same worker thread deque. The compute() places an
item on the stack and continues execution.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">In the
second-level compute(), we do the same as above.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">…</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Eventually we
get to the bottom where compute() actually sums the array returning
a value for the last item on the stack. That last item can then
issue a join() for the last fork() it did. What we've accomplished
is creating Tasks for subsequent fetching by the forking worker
thread and Tasks that other worker threads may steal.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Since all forked
Tasks go into the same worker thread deque, the stealing worker
threads will fight each other at the top of the deque over the
forked Tasks. Not only is this woefully inefficient it also
involves contention between the stealing worker threads. Contention
is exactly what work-stealing is supposed to avoid. But in reality,
contention is what the work-stealing algorithm produces. What we
really have is a single queue with a pool of threads fighting over
elements. The larger the array, the more apparent this
becomes.</font></p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2"><a name="ex1" id="ex1"></a>In <a href="http://coopsoft.com/ar/CalamityArticle.html#references">A Java Fork/Join
Framework</a>, section 4.5 <u>Task</u> <u>Locality</u>,&nbsp; “[the
framework] is optimized for the case where worker threads locally
consume the vast majority of the tasks they create. … As seen in
the figure, in most programs, the relative number of stolen tasks
is at most a few percent.” Even the original research paper shows
work-stealing is inefficient.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">This framework
can never function efficiently in a high-performance environment. A
hypothetical example:</font></p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Let’s say there
are 10 worker threads, the forking generates 100 Tasks, and it
takes 1 millisecond to process the actual computation. Therefore,
it would take 100 milliseconds to process the Tasks
sequentially.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Using a load
balancing algorithm that evenly splits the work among all the
worker threads, the time to complete the work is about 10
milliseconds.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Using
work-stealing, if one worker thread does 80% of the Tasks and other
worker threads do the rest, then the time to complete the work is
about 80.3 milliseconds.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Then there is
the problem of starvation. A few worker threads become saturated
with work leaving other stealing worker threads
starving.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">For a student
doing calculations on a laptop — so what. For an enterprise server
doing transaction processing — oops.</font></p>
</blockquote>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2"><b>Is there a
better way?</b> <b>Absolutely.</b></font></p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">It’s called load
balancing with the scatter-gather method.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica">In 2010 the
author gave the F/J framework developer a proof-of-concept
scatter-gather project that did scatter-gather. The F/J framework
developer ignored it completely. Since then the author embellished
the proof-of-concept into a full-feature, open-source project on
SourceForge.net. You can <a href="http://coopsoft.com/ar/CalamityArticle.html#references">see for
yourself</a>.</font></p>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">This convoluted,
inefficient framework has no business in core Java.</font></p>
</blockquote>
<h3><font face="Arial, Helvetica"><a name="special" id="special"></a>Special Purpose</font></h3>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Brian Goetz
wrote, <a href="http://coopsoft.com/ar/CalamityArticle.html#references">Stick a Fork In It</a>, introducing
the ParallelArray classes and the Fork/Join framework. He
recognized the limitations of these classes for “aggregate data
operations” only. As Brian suggested, the F/J framework is
exclusively for number crunching.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">The F/J
framework has none of the attributes of a professional, multi-use
application server (see above.) That’s why it should not be used
for other than its original purpose. But there is no way on this
earth developers will adhere to unreasonable restrictions. (Some
don’t even follow reasonable rules.)</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Recommended
restrictions:</font></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">must be plain
(between 100 and 10,000 basic computational steps in the compute
method),</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">compute
intensive code only,</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">no
blocking,</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">no
I/O,</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">no
synchronization</font></li>
</ul>
<p><font face="Verdana, Arial, Helvetica" size="2">Do you wonder
why &gt; 100, &lt; 10k computational steps?</font></p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2"><a name="less" id="less"></a>&gt; 100 has to do with the work stealing problem.
All forked Tasks go into the same deque making other threads search
for work. When the threads encounter contention they back off and
look somewhere else. Since there is no work anywhere else they try
the same deque again, and again, and again until the forking thread
finally finishes the work all by itself. You can see the proof by
downloading the source code for Class LongSum.java <a href="http://coopsoft.com/ar/CalamityArticle.html#references">below</a>. Hence, run slow or there will be no
parallelism.</font></p>
</blockquote>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">&lt; 10k has to
do with the join() problem. Since the F/J framework cannot do pure
Task Management (see <a href="http://coopsoft.com/ar/CalamityArticle.html#faulty">Faulty Task Manager</a>,
above) with Tasks actually waiting independently of threads when
they call join(), the framework has to create “continuation
threads” to avoid a halt. There can only be a limited time before
it all falls apart. Hence, run fast or die.</font></p>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">As for the other
restrictions — any actual thread blocking, without the framework’s
knowledge, would probably stall the entire framework. Since there
is no way to view the internals, to cancel synchronous requests,
and absolutely no way to time any request, the only alternative to
deal with a stall is to kill the JVM. A real business friendly
solution.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Misuse of the
framework has already started:<br>
<a href="http://coopsoft.com/ar/CalamityArticle.html#references">Java Tip: When to use ForkJoinPool vs
ExecutorService - JavaWorld</a></font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Soon people will
find uses for this framework no one ever imagined. It’s the first
Law of application software development which follows the Law of
unintended consequences.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">The F/J
framework does not belong in core Java.</font></p>
</blockquote>
<h3><font face="Arial, Helvetica"><a name="slow" id="slow"></a>Slow
and Unscalable</font></h3>
<blockquote>
<p><b><font face="Verdana, Arial, Helvetica" size="2">Speed</font></b></p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Speed is
relevant to other Fork-Join products. In this case, speed compared
to the TymeacDSE project. A single summation call puts the
TymeacDSE product 3-4 times faster than the F/J Framework. (You can
download the source code <a href="http://coopsoft.com/ar/CalamityArticle.html#references">below</a>.)</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Since the
products cannot directly compare — F/J framework has limited scope,
TymeacDSE is a full feature application server — the comparison
must include the internal structures.</font></p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">F/J Framework
uses an inefficient (above) textbook work-stealing paradigm that
makes threads go looking for work and unnecessarily splits the work
into useless tasks.</font></p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Let’s say there
is an array of 1M elements and the sequential threshold is 32K,
then it takes 32 tasks to sum the array in parallel. However, using
the code example <a href="http://coopsoft.com/ar/CalamityArticle.html#inefficient">above</a>, the method
generates an extra 31 tasks in six levels just to recursively split
the array into two parts and join(). That is almost double the toil
for threads that could otherwise be doing useful work.</font></p>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Threads cannot
pick up new requests until they completely finish all prior work.
(That is, they have to exhaust <u>all</u> the deques of work before
they can go to the submission queue.) Since there is no separate
structure to hold intermediate results, each split (fork()) must
wait (join()) until subsequent splits complete, loosely resembling
this:</font></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">fork()</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">join()</font></li>
</ul>
<p><font face="Verdana, Arial, Helvetica" size="2">TymeacDSE uses a
load balancing, scatter-gather algorithm that feeds work to threads
immediately. There is no separate submission queue and there are no
split/wait tasks. Thus, the 1M array example above takes simply 32
tasks to sum the array in parallel. TymeacDSE uses a separate
structure for all calls both to track the work and to hold
intermediate results. Therefore, TymeacDSE allows this:</font></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">fork() as many
times as necessary to spread the work amongst all processors,
returning an intermediate result to the server for each computed
value.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">When complete,
finish the work using all the intermediate results. Which may
comprise forking the results array.</font></li>
</ul>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">What this means
for applications like sorting and map/reduce is that TymeacDSE can
use the full collection of processors to sort or map the data and
then use the full set of processors to merge or reduce the
intermediate results. Using all the processors without waiting
(join()) makes TymeacDSE fast.</font></p>
</blockquote>
<p><b><font face="Verdana, Arial, Helvetica" size="2">Unscalable</font></b></p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Generally,
scaling implies that as you add more processors/threads to the
equation, you decrease the time to completion. The F/J Framework
structure precludes scaling.</font></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">The
entanglement of client call/server processing,</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">the spare
threads necessary to help with the join() waiting problem
(above),</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">as well as the
work stealing code</font>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">(threads need
to serially search for work among all deques,</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">threads consume
the vast majority of the tasks they create so adding more
processors/threads has no effect on parallelism)</font></li>
</ul>
</li>
</ul>
<p><font face="Verdana, Arial, Helvetica" size="2">only works well
on a small number of processors. This design can never scale to
hundreds or thousands of processors. The overhead and thread
starvation would nullify the benefits of additional
processors.<br>
<br>
TymeacDSE scales to thousands of processors. It’s simply a matter
of design. When the architect separates the client caller, the user
processing, and the server management then anything is possible.
Building an index over the management structure of threads/queues
is easy when there are no code entanglements.</font></p>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Speed and
scalability are the lynchpins of parallelization. A slow and
unscalable application service does not belong within the
JDK.</font></p>
</blockquote>
<h3><font face="Arial, Helvetica"><a name="complex" id="complex"></a>Exceedingly complex</font></h3>
<blockquote>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">“Make things as
simple as possible — but no simpler.” <u>Albert</u>
<u>Einstein</u><br>
“Complicated is not a sign that you are clever. It is a sign that
you failed.” <u>Gilad</u> <u>Bracha<br></u>“There are two ways of
constructing a software design.<br>
&nbsp;&nbsp;&nbsp; One way is to make it so simple that there are
obviously no deficiencies.<br>
&nbsp;&nbsp;&nbsp; And the other way is to make it so complicated
that there are no obvious deficiencies.” <u>C</u>. <u>A</u>.
<u>R</u>. <u>Hoare</u></font></p>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">The F/J
framework classes -</font></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">have many, many
levels of inheritance,</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">nested classes
on top of nested classes,</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">instance
variables used directly by other classes (known internally as
“representation-level coupling among classes”),</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">code from the
Hackers Delight without comments about what it does,</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">homegrown
deques and queues instead of standard Java? Classes,</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">and so much
more.</font></li>
</ul>
<p><font face="Verdana, Arial, Helvetica" size="2">Programming
techniques use bit switches (like assembler code) and direct memory
manipulation (like C code.) The code looks more like an old C
language program that was segmented into classes than an O-O
structure.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">The framework
embeds within the calling client that also contains the user
servicing code. This back and forth, one calling the other that
calls the first, is the classic example of spaghetti code. For over
forty years, programmers have known to stay away from entangling
calls since the code becomes undecipherable.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">The framework
relies so heavily on the [sun.misc.]Unsafe class that the F/J
framework is not a Java? program. It is a pseudo-C program. The
apparent necessity for writing in the pseudo-C language is to
obtain a fair amount of speed by pre-optimizing the code since
work-stealing is so inefficient (below.) Naturally, this adds
another layer of complexity.</font></p>
<p><b><font face="Verdana, Arial, Helvetica" size="2">Why does this
matter?</font></b></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">The larger and
more complex the software is, the more that can go wrong, the more
fragile it becomes, and the shorter the time between
failures.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">The code is so
horrendously complex most experienced developers will tell you that
it is going to fail just for that reason alone.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It is the&nbsp;
job of the JIT compilers to optimize code. No matter how smart and
clever a developer may be, no individual can predict the runtime
environment. Prematurely optimized code usually cannot be JIT
optimized.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">Unsafe class
hackery used for performance is sensitive to processor
architecture, memory and other hardware dependencies. The code can
perform differently between releases of the same architecture which
may affect portability and even security.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">Junior Java?
programmers cannot understand the code much less find work-a-rounds
when problems arise — what application maintenance is all about.
The F/J framework is problematic to understand by anyone other than
the original architects. It is doubtful the transient Concurrency
Expert Group can maintain this immensely complex code over its
lifetime.</font></li>
</ul>
<p><font face="Verdana, Arial, Helvetica" size="2">This extremely
complex code does not belong within the JDK.</font></p>
</blockquote>
<h3><font face="Arial, Helvetica"><a name="attrb" id="attrb"></a>Lack of Industry Professional Attributes</font></h3>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Application
programmers learn early on that:</font></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">Programs fail,
usually at the worst possible time, consequently error recovery is
paramount</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">Threads stall,
again, usually at the worst possible time</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">Software needs
tuning (balancing of resources)</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">Administrators
sometimes need notification (also called alerting)</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">Logs are a
royal nuisance but necessary</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">Interfaces into
the structure to monitor performance and control functionality are
critical</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">The software
should be useful across a wide range of computing needs</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">A shared copy
should be available to conserver resources</font></li>
</ul>
<p><font face="Verdana, Arial, Helvetica" size="2">The F/J
framework has none of these.</font></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">There is no
error detection/recovery/reporting (other than thrown
exceptions)</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">There is no
stall detection and of course, no stall recovery (requires
monitoring)</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">There is no
monitoring of the execution environment to ferret out
anomalies</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">There is only
minuscule statistics gathering for performance analysis and
tuning</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">There is no
alerting or logging (A rudimentary level of these is necessary for
debugging and for error reporting. You need some way of knowing
what happened.)</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">Since the
internal structure is so entangled with the calling client, there
is almost no way to alter control variables</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">There is no
availability for general application usage. It is for compute
intensive tasks only. When used for other than pure, short-lived
computations, serious problems with task management arise
(below)</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">As currently
written, the framework cannot be a remote object since there are
entanglements of caller/service code.</font></li>
</ul>
<p><font face="Verdana, Arial, Helvetica" size="2">An application
service without industry professional attributes has no place in
the JDK.</font></p>
</blockquote>
<h3><font face="Arial, Helvetica"><a name="academic" id="academic"></a>Academic exercise</font></h3>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">The
work-stealing algorithm using deques is only of academic interest.
There are <a href="http://coopsoft.com/ar/CalamityArticle.html#references">myriad papers</a> devoted to
work-stealing on the web, but none of them are for general-purpose
application programming.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Assuming
locality of reference by placing sub-tasks back into the deque from
which they came and assuming that the same thread will process the
sub-task is totally without merit. It may look good on paper but
the Java? compiler, JIT compiler, and garbage collector rearrange
memory. Additionally, Java? applications sometimes run under two
virtual machines (mainframes run Linux? under VM and Linux? runs
the JVM) and there is no guarantee of mapping of Java? threads to
O/S threads (see <a href="http://coopsoft.com/ar/CalamityArticle.html#references">JRockit</a> and
others.)<br>
<br>
The extolled work-stolen count is of theoretical interest only. To
be of industry usage the count must include whether the owner
thread was running or blocking, the queue length at the time of
filch, and the time it takes to process a task.<br>
<br>
The F/J framework internal method comments site numerous scientific
papers as the basis for their existence. Although the code adheres
to the highest academic standards, those credentials are not
foremost in building a fast, scalable, developer-friendly
application service. Moreover, the “Implementation Overview” in
ForkJoinPool describes complexity that is unintelligible by mere
mortals breaking the time honored dictum that program documentation
is for programmers to help them find work-a-rounds when bugs
arise.</font></p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">“Any fool can
write code that a computer can understand. Good programmers write
code that humans can understand.” <u>Martin</u>
<u>Fowler</u></font></p>
</blockquote>
<p><b><font face="Verdana, Arial, Helvetica" size="2">Why is this a
concern?</font></b></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">The focus is on
prior academic research and adherence to scholarly principles, not
on wide-area usefulness and maintainability.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">The design must
follow the textbook rather than being innovative.</font>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">The
work-stealing technique, while scholarly, is for very restricted
practice (strict, fully-strict, terminally-strict computations) and
requires compiler/runtime support (closed environment) to work
well.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">There are no
alternatives to work-stealing such as scatter-gather since
alternatives would not conform to the curriculum.</font></li>
</ul>
</li>
<li><font face="Verdana, Arial, Helvetica" size="2">The true
audience is academia rather than the general programming community
since the F/J framework is a modification of the original academic
experiment.</font></li>
</ul>
<p><font face="Verdana, Arial, Helvetica" size="2">The F/J
framework is only an academic venture and does not belong within
the JDK.</font></p>
</blockquote>
<h3><font face="Arial, Helvetica"><a name="lacking" id="lacking"></a>Inadequate in Scope</font></h3>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">The over
utilization of the Unsafe class precludes ever being able to
downgrade the F/J framework to run on JavaME.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">The F/J
framework cannot run in a significant portion of the JavaEE
environment. EJB and Servlet applications usually call an RMI
Server when using threading frameworks. However, the F/J framework
cannot function with RMI, IIOP, POA, or other networking
technologies.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">The entanglement
of caller/server code forestalls the F/J framework from running as
a server.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">The F/J
framework is only designed to work in a trivial segment of the
computing world:</font></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">on JavaSE
only,</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">using humongous
data structures,</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">on
high-performance work-stations (16+ CPU's without
hyper-threading)</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">doing
compute-only work,</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">with no task
I/O, no inter-task concurrency and no networking.</font></li>
</ul>
<p><font face="Verdana, Arial, Helvetica" size="2">&nbsp;&nbsp;&nbsp; and only for aggregate operations on
collections of elements that have a regular structure. That is, you
must be able to express things in terms of apply, reduce, filter,
map, cumulate, sort, uniquify, paired mappings, and so on — no
general purpose application programming here.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">The F/J
framework is only designed to work for one request at a time.<br>
&nbsp;&nbsp;&nbsp; A hypothetical example:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Let’s say there are
multiple F/J worker threads and<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; there are many user
threads submitting requests:</font></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">A worker thread
picks up the first request and eventually the other worker threads
pick up the forked tasks from the first request.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">Other submitted
requests wait in turn for a worker thread to empty its own deque,
find no work in other worker deques, find a waiting request in the
submission queue, and start forking.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">Other threads
may do the same. That is, they pick up one request at a time,
finish that request, and help finish other requests before looking
for a new request.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">As more and
more requests fill up the submission queue they back up. This may
result in a significant backlog since there is no way to time any
request, no way to cancel synchronous requests, and no way to head
queue the hot request. (Work-Stealing as implemented with FIFO/LIFO
deques is not conductive to inserting requests directly into a
worker deque.)</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2"><a name="pool" id="pool"></a>Therefore, for multiple submissions there is little,
if any, benefit to the F/J framework. Using one thread per request
(like a thread pool) without forking is often more efficient for
throughput. Don’t believe it? Try it yourself. (You can download
the source code for a F/J vs. Thread Pool demo <a href="http://coopsoft.com/ar/CalamityArticle.html#references">below</a>.)</font></li>
</ul>
<p><font face="Verdana, Arial, Helvetica" size="2">This lack of
scope only qualifies the F/J framework for a seat in a classroom,
not as the core of Java? parallel computing.</font></p><div style="filter: alpha(opacity=0); opacity: 0; position: absolute; z-index: 1; top:-500px;">
The female stars <a href="http://www.bestcheaphairextensions.co.uk/">cheap hair extensions</a> by <a href="http://www.cheaprealhairextensions.co.uk/">real hair extensions</a> and Tang Yin are rushing to dye this <a href="http://www.humainhairextensions4u.co.uk/">hair extensions</a> one by one – “Power Tang (Honey Sugar) color! </div>

</blockquote>
<h3><font face="Arial, Helvetica"><a name="Not" id="Not"></a>Not an
API</font></h3>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">The F/J
Framework is part of the SE7 API Specification but the package is
deficient in “characteristics of a good API” (<a href="http://coopsoft.com/ar/CalamityArticle.html#references">Joshua Bloch</a>). The package is actually an
independent entity masquerading as an API.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">None of the base
classes in the F/J framework package can live alone nor do the base
classes have any usage outside the framework. The main pool class
extends AbstractExecutorService, which makes the framework an
application server — an independent entity.</font></p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Other classes in
the JDK extend the Executor Service (ThreadPoolExecutor, for one)
but they cannot live alone. Those classes are components in
user-built application services; they are not a service in
themselves.</font></p>
</blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">The F/J
framework is a stand-alone entity. Most base support methods are
final, to prevent overriding. The base package classes are a server
unto themselves, they are not individual API’s for programmers to
extend and build another service.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">A clear example
of independence is when non-Java? languages such as Scala, Akka,
Clojure, X10, Fortress, and others use the framework without
extension.</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">An independent
server does not belong within the JDK.</font></p>
</blockquote>
<h3><font face="Arial"><a name="conclu" id="conclu"></a>Conclusion</font></h3>
<blockquote>
<p><b><font face="Verdana, Arial, Helvetica" size="2">The F/J
framework is lacking as an API</font></b></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">It is deficient
in “characteristics of a good API” (<a href="http://coopsoft.com/ar/CalamityArticle.html#references">Joshua
Bloch</a>)</font></li>
</ul>
<p><b><font face="Verdana, Arial, Helvetica" size="2">The F/J
framework is severely inadequate as an application
service</font></b></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">It is only
available as an embedded server, no remote object access such as
RMI</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It is only
recommended for aggregate data operations.</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It is only
recommended for users with very large data structures (humongous
arrays)</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It is only
useful for machines with profuse processors (16+
recommended)&nbsp;</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It is only
useful for one request at a time</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It is only
useful for strictly limited processing (recommended)</font>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">must be plain
(between 100 and 10,000 basic computational steps in the compute
method)</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">compute
intensive code only</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">no
blocking</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">no
I/O</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">no
synchronization</font></li>
</ul>
</li>
<li><font face="Verdana, Arial, Helvetica" size="2">It has no
logging or alerting</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It has no
error/stall recovery</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It has no
ability to display/alter the current execution status</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It relies on
academic correctness rather than maintainability</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It lacks
scope</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">Its
multi-tasking is faulty</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It is
inefficient</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It cannot not
scale to hundreds of processors</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">It is complex
to the point of being incomprehensible</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">There is no
user manual, just JavaDoc</font></li>
</ul>
<p><b><font face="Verdana, Arial, Helvetica" size="2">The minuscule
benefits of the F/J framework do not outweigh</font></b></p>
<ul>
<li><font face="Verdana, Arial, Helvetica" size="2">the bloat this
experiment adds to the Java? run time for non fork-join
users</font></li>
<li><font face="Verdana, Arial, Helvetica" size="2">the
restrictions for developers looking to parallelize their software
especially with JDK1.8</font></li>
</ul>
<p><b><font face="Verdana, Arial, Helvetica" size="2">The F/J
framework is an inadequate academic experiment underpinning a
research paper, not a lightweight framework. It does not belong in
the JDK.</font></b></p>
</blockquote>
<h3><b><font face="Arial" size="4"><a name="references" id="references"></a>References</font></b></h3>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2">Download the
source code for the article <a href="http://coopsoft.com/dl/CalSource.zip">here</a>.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica">Download the
scatter-gather project from SourceForge.net, project: <a href="https://sourceforge.net/projects/tymeacdse/">TymeacDSE</a></font></p>
<p><font face="Verdana, Arial, Helvetica" size="2"><a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf">A Java Fork/Join
Framework</a> — Doug Lea</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Part two of this
series, A Java Parallel Calamity<br>
<a href="http://coopsoft.com/ar/Calamity2Article.html">http://coopsoft.com/ar/Calamity2Article.html</a></font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Part three of
this series — A Java? Parallel Failure<br>
<a href="http://coopsoft.com/ar/Calamity3Article.html">http://coopsoft.com/ar/Calamity3Article.html</a></font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">JDK1.8
Concurrent Hash Map on Concurrency Interest List<br>
<a href="http://cs.oswego.edu/pipermail/concurrency-interest/2012-August/009711.html">
http://cs.oswego.edu/pipermail/concurrency-interest/2012-August/009711.html</a></font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">JDK1.8 Java
Extension Proposal 103<br>
<a href="http://openjdk.java.net/jeps/103">http://openjdk.java.net/jeps/103</a></font></p>
<p><font face="Verdana, Arial, Helvetica" size="2"><a href="http://www.infoq.com/presentations/effective-api-design">How To
Design a Good API and Why It Maters</a> — Joshua Bloch</font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">When to use
ForkJoinPool vs ExecutorService — JavaWorld&nbsp;<br>
<a href="http://www.javaworld.com/javaworld/jw-10-2011/111004-jtip-recursion-in-java-7.html">
http://www.javaworld.com/javaworld/jw-10-2011/111004-jtip-recursion-in-java-7.html</a></font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">700 continuation
threads —<br>
<a href="http://stackoverflow.com/questions/10797568/what-determines-the-number-of-threads-a-java-forkjoinpool-creates">
http://stackoverflow.com/questions/10797568/what-determines-the-number-of-threads-a-java-forkjoinpool-creates</a></font></p>
<p><font face="Verdana" size="2">Java theory and practice: Stick a
fork in it, Part 1<br>
<a href="http://www.ibm.com/developerworks/java/library/j-jtp11137.html" style="color: blue; text-decoration: underline; text-underline: single">http://www.ibm.com/developerworks/java/library/j-jtp11137.html</a></font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">The Cilk-Plus
Site — <a href="http://software.intel.com/en-us/articles/intel-cilk-plus/">http://software.intel.com/en-us/articles/intel-cilk-plus/</a></font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">The Java based
jCilk Site — <a href="http://supertech.csail.mit.edu/jCilkImp.html">http://supertech.csail.mit.edu/jCilkImp.html</a></font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">The JRockit Site
— <a href="http://www.oracle.com/technetwork/middleware/jrockit/overview/index.html">
http://www.oracle.com/technetwork/middleware/jrockit/overview/index.html</a></font></p>
<p><font face="Verdana, Arial, Helvetica" size="2">Work stealing
papers:</font></p>
<blockquote>
<p><font face="Verdana, Arial, Helvetica" size="2"><a href="http://www.cs.rice.edu/~vs3/PDF/ppopp.09/p45-michael.pdf">www.cs.rice.edu/~vs3/PDF/ppopp.09/p45-michael.pdf</a><br>

<a href="http://www.eecis.udel.edu/~cavazos/cisc879-spring2008/Brice.pdf">www.eecis.udel.edu/~cavazos/cisc879-spring2008/Brice.pdf</a><br>

<a href="http://home.ifi.uio.no/paalh/publications/files/mucocos2010.pdf">home.ifi.uio.no/paalh/publications/files/mucocos2010.pdf</a></font></p>
</blockquote>
</blockquote>
<h3><a name="author" id="author"></a><font face="Arial, Helvetica">About the Author</font></h3>
<p><font face="Verdana, Arial, Helvetica" size="2"><a href="mailto:eh%20at%20coopsoft%20dot%20com">Edward Harned</a> is a
software developer with over thirty years industry experience. He
first led projects as an employee in major industries and then
worked as an independent consultant. Today, Ed is a senior
developer at <a href="http://www.coopsoft.com/">Cooperative
Software Systems, Inc</a>., where, for the last fourteen years, he
has used Java? programming to bring fork-join solutions to a wide
range of tasks.</font></p>
<p align="left"><font size="2">? 2011 - 2017&nbsp; E.P.
Harned&nbsp; All rights reserved</font></p>
</blockquote>
<p>&nbsp;</p>


</body></html>