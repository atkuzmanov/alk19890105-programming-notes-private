<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0054)https://martinfowler.com/articles/micro-frontends.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="uft-8" name="charset">

<title>Micro Frontends</title>

<meta content="summary_large_image" name="twitter:card">

<meta content="16665197" name="twitter:site:id">

<meta content="Micro Frontends" property="og:title">

<meta content="https://martinfowler.com/articles/micro-frontends.html" property="og:url">

<meta content="How to split up your large, complex, frontend codebases into simple, composable, independently deliverable apps." property="og:description">

<meta content="https://martinfowler.com/articles/micro-frontends/card.png" property="og:image">

<meta content="martinfowler.com" property="og:site_name">

<meta content="article" property="og:type">

<meta content="2019-06-19" property="og:article:modified_time">

<meta content="@thecamjackson" name="twitter:creator">

<meta content="width=device-width, initial-scale=1" name="viewport">

<link href="./Micro Frontends_files/micro-frontends.css" rel="stylesheet" type="text/css">
</head>

<body><header id="banner" style="background-image: url(&quot;/img/zakim.png&quot;); background-repeat: no-repeat">

<div class="name-logo"><a href="https://martinfowler.com/"><img src="./Micro Frontends_files/mf-name-white.png"></a></div>
  <div class="search">
    <!-- SiteSearch Google -->
    <form method="GET" action="https://www.google.com/search">
      <input type="hidden" name="ie" value="UTF-8">
      <input type="hidden" name="oe" value="UTF-8">
      <input class="field" type="text" name="q" size="15" maxlength="255" value="">
      <button class="button" type="submit" name="btnG" value=" " title="Search">
      <input type="hidden" name="domains" value="martinfowler.com">
      <input type="hidden" name="sitesearch" value=""> 
      <input type="hidden" name="sitesearch" value="martinfowler.com">
    
  </button></form></div>

<div class="menu-button navmenu-button"><a class="icon icon-bars" href="https://martinfowler.com/articles/micro-frontends.html#navmenu-bottom"></a></div>

<nav class="top-menu">
<ul>
<li><a class="" href="https://refactoring.com/">Refactoring</a></li>

<li><a class="" href="https://martinfowler.com/agile.html">Agile</a></li>

<li><a class="" href="https://martinfowler.com/architecture">Architecture</a></li>

<li><a class="" href="https://martinfowler.com/aboutMe.html">About</a></li>

<li><a class="tw" href="https://www.thoughtworks.com/">ThoughtWorks</a></li>

<li><a class="icon icon-rss" href="https://martinfowler.com/feed.atom" title="feed"></a></li>

<li><a class="icon icon-twitter" href="https://www.twitter.com/martinfowler" title="twitter stream"></a></li>
</ul>
</nav>
</header>
<nav id="top-navmenu">
<nav class="navmenu">
<div class="nav-head">  <div class="search">
    <!-- SiteSearch Google -->
    <form method="GET" action="https://www.google.com/search">
      <input type="hidden" name="ie" value="UTF-8">
      <input type="hidden" name="oe" value="UTF-8">
      <input class="field" type="text" name="q" size="15" maxlength="255" value="">
      <button class="button" type="submit" name="btnG" value=" " title="Search">
      <input type="hidden" name="domains" value="martinfowler.com">
      <input type="hidden" name="sitesearch" value=""> 
      <input type="hidden" name="sitesearch" value="martinfowler.com">
    
  </button></form></div>

<div class="closediv">
<span class="close" title="close"></span>
</div>
</div>

<div class="nav-body">
<div class="topics">
<h2>Topics</h2>

<p><a href="https://martinfowler.com/architecture">Architecture</a></p>

<p><a href="https://refactoring.com/">Refactoring</a></p>

<p><a href="https://martinfowler.com/agile.html">Agile</a></p>

<p><a href="https://martinfowler.com/delivery.html">Delivery</a></p>

<p><a href="https://martinfowler.com/microservices">Microservices</a></p>

<p><a href="https://martinfowler.com/data">Data</a></p>

<p><a href="https://martinfowler.com/testing">Testing</a></p>

<p><a href="https://martinfowler.com/dsl.html">DSL</a></p>
</div>

<div class="about">
<h2>about me</h2>

<p><a href="https://martinfowler.com/aboutMe.html">About</a></p>

<p><a href="https://martinfowler.com/books">Books</a></p>

<p><a href="https://martinfowler.com/faq.html">FAQ</a></p>
</div>

<div class="content">
<h2>content</h2>

<p><a href="https://martinfowler.com/videos.html">Videos</a></p>

<p><a href="https://martinfowler.com/tags">Content Index</a></p>

<p><a href="https://martinfowler.com/articles/eurogames">Board Games</a></p>

<p><a href="https://martinfowler.com/photos">Photography</a></p>
</div>

<div class="tw">
<h2>ThoughtWorks</h2>

<p><a href="https://thoughtworks.com/insights">Insights</a></p>

<p><a href="https://thoughtworks.com/careers">Careers</a></p>

<p><a href="https://thoughtworks.com/products">Products</a></p>
</div>

<div class="feeds">
<h2>follow</h2>

<p><a href="https://www.twitter.com/martinfowler">Twitter</a></p>

<p><a href="https://martinfowler.com/feed.atom">RSS</a></p>
</div>
</div>
</nav>
</nav>

<div class="contents dropdown-container">
<button class="dropdown-button">
<h2>Contents</h2>
</button>

<div class="hidden" id="dropdownLinks"><a href="https://martinfowler.com/articles/micro-frontends.html#Benefits">Benefits</a>
<ul>
<li><a href="https://martinfowler.com/articles/micro-frontends.html#IncrementalUpgrades">Incremental upgrades</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#SimpleDecoupledCodebases">Simple, decoupled codebases</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#IndependentDeployment">Independent deployment</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#AutonomousTeams">Autonomous teams</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#InANutshell">In a nutshell</a></li>
</ul>
<a href="https://martinfowler.com/articles/micro-frontends.html#TheExample">The example</a><a href="https://martinfowler.com/articles/micro-frontends.html#IntegrationApproaches">Integration approaches</a>
<ul>
<li><a href="https://martinfowler.com/articles/micro-frontends.html#Server-sideTemplateComposition">Server-side template composition</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Build-timeIntegration">Build-time integration</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Run-timeIntegrationViaIframes">Run-time integration via iframes</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Run-timeIntegrationViaJavascript">Run-time integration via JavaScript</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Run-timeIntegrationViaWebComponents">Run-time integration via Web Components</a></li>
</ul>
<a href="https://martinfowler.com/articles/micro-frontends.html#Styling">Styling</a><a href="https://martinfowler.com/articles/micro-frontends.html#SharedComponentLibraries">Shared component libraries</a><a href="https://martinfowler.com/articles/micro-frontends.html#Cross-applicationCommunication">Cross-application communication</a><a href="https://martinfowler.com/articles/micro-frontends.html#BackendCommunication">Backend communication</a><a href="https://martinfowler.com/articles/micro-frontends.html#Testing">Testing</a><a href="https://martinfowler.com/articles/micro-frontends.html#TheExampleInDetail">The example in detail</a>
<ul>
<li><a href="https://martinfowler.com/articles/micro-frontends.html#TheContainer">The container</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#TheMicroFrontends">The micro frontends</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Cross-applicationCommunicationViaRouting">Cross-application communication via routing</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#CommonContent">Common content</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Infrastructure">Infrastructure</a></li>
</ul>
<a href="https://martinfowler.com/articles/micro-frontends.html#Downsides">Downsides</a>
<ul>
<li><a href="https://martinfowler.com/articles/micro-frontends.html#PayloadSize">Payload size</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#EnvironmentDifferences">Environment differences</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#OperationalAndGovernanceComplexity">Operational and governance complexity</a></li>
</ul>
<a href="https://martinfowler.com/articles/micro-frontends.html#Conclusion">Conclusion</a></div>
</div>

<main>
<h1>Micro Frontends</h1>

<p class="abstract"><i>
    Good frontend development is hard. Scaling frontend development so that many
    teams can work simultaneously on a large and complex product is even harder.
    In this article we'll describe a recent trend of breaking up frontend
    monoliths into many smaller, more manageable pieces, and how this
    architecture can increase the effectiveness and efficiency of teams working
    on frontend code. As well as talking about the various benefits and costs,
    we'll cover some of the implementation options that are available, and we'll
    dive deep into a full example application that demonstrates the technique.
  </i></p>

<p class="date">19 June 2019</p>

<div class="frontMatter">
<div class="frontLeft">
<div class="author"><a href="https://camjackson.net/"><img alt="Photo of Cam Jackson" src="./Micro Frontends_files/cam-avatar.jpg" width="80"></a>
<p class="name"><a href="https://camjackson.net/">Cam Jackson</a></p>

<div class="bio">
<p>
        Cam Jackson is a full-stack web developer and consultant at
        ThoughtWorks, with a particular interest in how large organisations
        scale their frontend development process and practices. He has worked
        with clients across multiple industries and countries, helping them to
        deliver web applications more efficiently and effectively.
      </p>
</div>
</div>

<div class="clear"></div>

<div class="tags">
<p class="tag-link"><a href="https://martinfowler.com/tags/application%20architecture.html">application architecture</a></p>

<p class="tag-link"><a href="https://martinfowler.com/tags/front-end.html">front-end</a></p>

<p class="tag-link"><a href="https://martinfowler.com/tags/microservices.html">microservices</a></p>
</div>
</div>

<div class="frontRight">
<div class="contents">
<h2>Contents</h2>

<ul>
<li><a href="https://martinfowler.com/articles/micro-frontends.html#Benefits">Benefits</a>
<ul>
<li><a href="https://martinfowler.com/articles/micro-frontends.html#IncrementalUpgrades">Incremental upgrades</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#SimpleDecoupledCodebases">Simple, decoupled codebases</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#IndependentDeployment">Independent deployment</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#AutonomousTeams">Autonomous teams</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#InANutshell">In a nutshell</a></li>
</ul>
</li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#TheExample">The example</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#IntegrationApproaches">Integration approaches</a>
<ul>
<li><a href="https://martinfowler.com/articles/micro-frontends.html#Server-sideTemplateComposition">Server-side template composition</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Build-timeIntegration">Build-time integration</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Run-timeIntegrationViaIframes">Run-time integration via iframes</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Run-timeIntegrationViaJavascript">Run-time integration via JavaScript</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Run-timeIntegrationViaWebComponents">Run-time integration via Web Components</a></li>
</ul>
</li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Styling">Styling</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#SharedComponentLibraries">Shared component libraries</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Cross-applicationCommunication">Cross-application communication</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#BackendCommunication">Backend communication</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Testing">Testing</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#TheExampleInDetail">The example in detail</a>
<ul>
<li><a href="https://martinfowler.com/articles/micro-frontends.html#TheContainer">The container</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#TheMicroFrontends">The micro frontends</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Cross-applicationCommunicationViaRouting">Cross-application communication via routing</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#CommonContent">Common content</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Infrastructure">Infrastructure</a></li>
</ul>
</li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Downsides">Downsides</a>
<ul>
<li><a href="https://martinfowler.com/articles/micro-frontends.html#PayloadSize">Payload size</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#EnvironmentDifferences">Environment differences</a></li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#OperationalAndGovernanceComplexity">Operational and governance complexity</a></li>
</ul>
</li>

<li><a href="https://martinfowler.com/articles/micro-frontends.html#Conclusion">Conclusion</a></li>
</ul>
</div>
</div>
</div>

<div class="paperBody deep">
<p>In recent years, <a href="https://martinfowler.com/articles/microservices.html">microservices</a> have
    exploded in popularity, with many organisations using this architectural
    style to avoid the limitations of large, monolithic backends. While much has
    been written about this style of building server-side software, many
    companies continue to struggle with monolithic frontend codebases.</p>

<p>Perhaps you want to build a progressive or responsive web application, but
    can't find an easy place to start integrating these features into the existing
    code. Perhaps you want to start using new JavaScript language features (or
    one of the myriad languages that can compile to JavaScript), but you can't
    fit the necessary build tools into your existing build process. Or maybe you
    just want to scale your development so that multiple teams can work on a
    single product simultaneously, but the coupling and complexity in the
    existing monolith means that everyone is stepping on each other's toes.
    These are all real problems that can all negatively affect your ability to
    efficiently deliver high quality experiences to your customers.</p>

<p>Lately we are seeing more and more attention being paid to the overall
    architecture and organisational structures that are necessary for complex,
    modern web development. In particular, we're seeing patterns emerge for
    decomposing frontend monoliths into smaller, simpler chunks that can be
    developed, tested and deployed independently, while still appearing to
    customers as a single cohesive product. We call this technique
    <b>micro frontends</b>, which we define as:</p>

<blockquote>
<p>"An architectural style where independently deliverable frontend
    applications are composed into a greater whole"</p>
</blockquote>

<p>In the November 2016 issue of the ThoughtWorks technology radar, we
    listed <a href="https://www.thoughtworks.com/radar/techniques/micro-frontends">micro frontends</a> as a technique that
    organisations should Assess. We later promoted it into Trial, and finally
    into Adopt, which means that we see it as a proven approach that you should
    be using when it makes sense to do so.</p>

<div class="figure " id="radar.png"><img alt="A screenshot of micro frontends on the       ThoughtWorks tech radar" src="./Micro Frontends_files/radar.png">
<p class="photoCaption">Figure 1: Micro frontends has appeared on the tech radar
      several times.
    </p>
</div>

<div class="clear"></div>

<p>Some of the key benefits that we've seen from micro frontends are:</p>

<ul>
<li>smaller, more cohesive and maintainable codebases</li>

<li>more scalable organisations with decoupled, autonomous teams</li>

<li>the ability to upgrade, update, or even rewrite parts of the frontend
      in a more incremental fashion than was previously possible</li>
</ul>

<p>
    It is no coincidence that these headlining advantages are some of the same
    ones that microservices can provide.</p>

<p>Of course, there are no free lunches when it comes to software
    architecture - everything comes with a cost. Some micro frontend
    implementations can lead to duplication of dependencies, increasing the
    number of bytes our users must download. In addition, the dramatic increase
    in team autonomy can cause fragmentation in the way your teams work.
    Nonetheless, we believe that these risks can be managed, and that the
    benefits of micro frontends often outweigh the costs.</p>

<section id="Benefits">
<h2>Benefits</h2>

<p>Rather than defining micro frontends in terms of specific technical
      approaches or implementation details, we instead place emphasis on the
      attributes that emerge and the benefits they give.</p>

<section id="IncrementalUpgrades">
<h3>Incremental upgrades</h3>

<p>For many organisations this is the beginning of their micro frontends
        journey. The old, large, frontend monolith is being held back by
        yesteryear's tech stack, or by code written under delivery pressure, and
        it's getting to the point where a total rewrite is tempting. In order to
        avoid the
        <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/">perils</a>
        of a full rewrite, we'd much prefer to
        <a href="https://martinfowler.com/bliki/StranglerApplication.html">strangle</a>
        the old application piece by piece, and in the meantime continue to
        deliver new features to our customers without being weighed down by the
        monolith.</p>

<p>This often leads towards a micro frontends architecture. Once one
        team has had the experience of getting a feature all the way to production
        with little modification to the old world, other teams will want to join the
        new world as well. The existing code still needs to be maintained, and
        in some cases it may make sense to continue to add new features to it,
        but now the choice is available.</p>

<p>The endgame here is that we're afforded more freedom to make
        case-by-case decisions on individual parts of our product, and to make
        incremental upgrades to our architecture, our dependencies, and our user
        experience. If there is a major breaking change in our main framework,
        each micro frontend can be upgraded whenever it makes sense, rather than
        being forced to stop the world and upgrade everything at once. If we
        want to experiment with new technology, or new modes of interaction, we
        can do it in a more isolated fashion than we could before.</p>
</section>

<section id="SimpleDecoupledCodebases">
<h3>Simple, decoupled codebases</h3>

<p>The source code for each individual micro frontend will by definition
        be much smaller than the source code of a single monolithic frontend.
        These smaller codebases tend to be simpler and easier for developers to
        work with. In particular, we avoid the complexity arising from
        unintentional and inappropriate coupling between components
        that should not know about each other. By drawing thicker lines around
        the <a href="https://martinfowler.com/bliki/BoundedContext.html">bounded contexts</a> of the
        application, we make it harder for such accidental coupling to arise.</p>

<p>Of course, a single, high-level architectural decision (i.e. "let's
        do micro frontends"), is not a substitute for good old fashioned clean
        code. We're not trying to exempt ourselves from thinking about our code
        and putting effort into its quality. Instead, we're trying to set
        ourselves up to fall into the <a href="https://blog.codinghorror.com/falling-into-the-pit-of-success/">pit of success
        </a> by making bad decisions hard, and good ones easy. For example,
        sharing domain models across bounded contexts becomes more difficult, so
        developers are less likely to do so. Similarly, micro frontends push you
        to be explicit and deliberate about how data and events flow between
        different parts of the application, which is something that we should
        have been doing anyway!</p>
</section>

<section id="IndependentDeployment">
<h3>Independent deployment</h3>

<p>Just as with microservices, independent deployability of micro
        frontends is key. This reduces the scope of any given deployment,
        which in turn reduces the associated risk. Regardless of how or where
        your frontend code is hosted, each micro frontend should have its own
        continuous delivery pipeline, which builds, tests and deploys
        it all the way to production. We should be able to deploy each
        micro frontend with very little thought given to the current state of
        other codebases or pipelines. It shouldn't matter if the old monolith is
        on a fixed, manual, quarterly release cycle, or if the team next door
        has pushed a half-finished or broken feature into their master branch.
        If a given micro frontend is ready to go to production, it should be
        able to do so, and that decision should be up to the team who build and
        maintain it.</p>

<div class="figure " id="deployment.png"><img alt="A diagram showing 3 applications independently going from source control, through build, test and deployment to production" src="./Micro Frontends_files/deployment.png">
<p class="photoCaption">Figure 2: Each micro frontend is deployed to production independently</p>
</div>

<div class="clear"></div>
</section>

<section id="AutonomousTeams">
<h3>Autonomous teams</h3>

<p>As a higher-order benefit of decoupling both our codebases and our
        release cycles, we get a long way towards having fully independent
        teams, who can own a section of a product from ideation through to
        production and beyond. Teams can have full ownership of everything they
        need to deliver value to customers, which enables them to move quickly
        and effectively. For this to work, our teams need to be formed around
        vertical slices of business functionality, rather than around technical
        capabilities. An easy way to do this is to carve up the product
        based on what end users will see, so each micro frontend encapsulates a
        single page of the application, and is owned end-to-end by a single team.
        This brings higher cohesiveness of the teams' work than if teams were
        formed around technical or “horizontal” concerns like styling, forms, or
        validation.</p>

<div class="figure " id="horizontal.png"><img alt="A diagram showing teams formed around 3 applications, and warning against forming a &#39;styling&#39; team" src="./Micro Frontends_files/horizontal.png">
<p class="photoCaption">Figure 3: Each application
        should be owned by a single team</p>
</div>

<div class="clear"></div>
</section>

<section id="InANutshell">
<h3>In a nutshell</h3>

<p>In short, micro frontends are all about slicing up big and scary things
        into smaller, more manageable pieces, and then being explicit about the
        dependencies between them. Our technology choices, our codebases, our
        teams, and our release processes should all be able to operate and
        evolve independently of each other, without excessive coordination.</p>
</section>
</section>

<section id="TheExample">
<h2>The example</h2>

<p>Imagine a website where customers can order food for delivery. On the
      surface it's a fairly simple concept, but there's a surprising amount of
      detail if you want to do it well:</p>

<ul>
<li>There should be a landing page where customers can browse and search
        for restaurants. The restaurants should be searchable and filterable by any
        number of attributes including price, cuisine, or what a customer has
        ordered previously</li>

<li>Each restaurant needs its own page that shows its menu items, and
        allows a customer to choose what they want to eat, with discounts, meal
        deals, and special requests</li>

<li>Customers should have a profile page where they can see their order
        history, track delivery, and customise their payment options</li>
</ul>

<div class="figure " id="wireframe.png"><img alt="A wireframe of a food delivery website" src="./Micro Frontends_files/wireframe.png">
<p class="photoCaption">Figure 4: 
        A food delivery website may have several reasonably complex pages
      </p>
</div>

<div class="clear"></div>

<p>There is enough complexity in each page that we could easily justify a
      dedicated team for each one, and each of those teams should be able to
      work on their page independently of all the other teams. They should be
      able to develop, test, deploy, and maintain their code without worrying
      about conflicts or coordination with other teams. Our customers, however,
      should still see a single, seamless website.</p>

<p>Throughout the rest of this article, we'll be using this example
      application wherever we need example code or scenarios.</p>
</section>

<section id="IntegrationApproaches">
<h2>Integration approaches</h2>

<p>Given the fairly loose definition above, there are many approaches that
      could reasonably be called micro frontends. In this section we'll show
      some examples and discuss their tradeoffs. There is a fairly natural
      architecture that emerges across all of the approaches - generally there is
      a micro frontend for each page in the application, and there is a single
      <b>container application</b>, which:</p>

<ul>
<li>renders common page elements such as headers and footers</li>

<li>addresses cross-cutting concerns like authentication and navigation</li>

<li>brings the various micro frontends together onto the page, and tells
        each micro frontend when and where to render itself</li>
</ul>

<div class="figure " id="composition.png"><img alt="A web page with boxes drawn around different sections. One box wraps the whole page, labelling it as the &#39;container application&#39;. Another box wraps the main content (but not the global page title and navigation), labelling it as the &#39;browse micro frontend&#39;" src="./Micro Frontends_files/composition.png">
<p class="photoCaption">Figure 5: You can
      usually derive your architecture from the visual structure of the page
      </p>
</div>

<div class="clear"></div>

<section id="Server-sideTemplateComposition">
<h3>Server-side template composition</h3>

<p>We start with a decidedly un-novel approach to frontend development -
        rendering HTML on the server out of multiple templates or fragments. We
        have an <code>index.html</code> which contains any common page elements,
        and then uses server-side includes to plug in page-specific content from
        fragment HTML files:</p>

<pre class="code hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">dir</span>=<span class="hljs-string">"ltr"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Feed me<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>🍽 Feed me<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-comment">&lt;!--# include file="$PAGE.html" --&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</pre>

<p>We serve this file using Nginx, configuring the <code>$PAGE</code>
        variable by matching against the URL that is being requested:</p>

<pre class="code hljs nginx"><span class="hljs-section">server</span> {
    <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;
    <span class="hljs-attribute">server_name</span> localhost;

    <span class="hljs-attribute">root</span> /usr/share/nginx/html;
    <span class="hljs-attribute">index</span> index.html;
    <span class="hljs-attribute">ssi</span> <span class="hljs-literal">on</span>;

    <span class="hljs-comment"># Redirect / to /browse</span>
    <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/$</span> http://localhost:8080/browse <span class="hljs-literal">redirect</span>;

    <span class="hljs-comment"># Decide which HTML fragment to insert based on the URL</span>
    <span class="hljs-attribute">location</span> /browse {
      <span class="hljs-attribute">set</span> <span class="hljs-variable">$PAGE</span> <span class="hljs-string">'browse'</span>;
    }
    <span class="hljs-attribute">location</span> /order {
      <span class="hljs-attribute">set</span> <span class="hljs-variable">$PAGE</span> <span class="hljs-string">'order'</span>;
    }
    <span class="hljs-attribute">location</span> /profile {
      <span class="hljs-attribute">set</span> <span class="hljs-variable">$PAGE</span> <span class="hljs-string">'profile'</span>
    }

    <span class="hljs-comment"># All locations should render through index.html</span>
    error_page <span class="hljs-number">404</span> /index.html;
}
</pre>

<p>This is fairly standard server-side composition. The reason we could
        justifiably call this micro frontends is that we've split up our code in
        such a way that each piece represents a self-contained domain concept
        that can be delivered by an independent team. What's not shown here is
        how those various HTML files end up on the web server, but the
        assumption is that they each have their own deployment pipeline, which
        allows us to deploy changes to one page without affecting or thinking
        about any other page.</p>

<p>For even greater independence, there could be a separate server
        responsible for rendering and serving each micro frontend, with one
        server out the front that makes requests to the others. With careful
        caching of responses, this could be done without impacting latency.</p>

<div class="figure " id="ssi.png"><img alt="A flow diagram showing a browser making a request to a &#39;container app server&#39;, which then makes requests to one of either a &#39;browse micro frontend server&#39; or a &#39;order micro frontend server&#39;" src="./Micro Frontends_files/ssi.png">
<p class="photoCaption">Figure 6: Each of
these servers can be built and deployed to independently
        </p>
</div>

<div class="clear"></div>

<p>This example shows how micro frontends is not necessarily a new
        technique, and does not have to be complicated. As long as we're careful
        about how our design decisions affect the autonomy of our codebases and
        our teams, we can achieve many of the same benefits regardless of our
        tech stack.</p>
</section>

<section id="Build-timeIntegration">
<h3>Build-time integration</h3>

<p>One approach that we sometimes see is to publish each micro frontend
        as a package, and have the container application include them all as
        library dependencies. Here is how the container's <code>package.json</code> might
        look for our example app:</p>

<pre class="code hljs json">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"@feed-me/container"</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"1.0.0"</span>,
  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"A food delivery web app"</span>,
  <span class="hljs-attr">"dependencies"</span>: {
    <span class="hljs-attr">"@feed-me/browse-restaurants"</span>: <span class="hljs-string">"^1.2.3"</span>,
    <span class="hljs-attr">"@feed-me/order-food"</span>: <span class="hljs-string">"^4.5.6"</span>,
    <span class="hljs-attr">"@feed-me/user-profile"</span>: <span class="hljs-string">"^7.8.9"</span>
  }
}
</pre>

<p>At first this seems to make sense. It produces a single deployable
        Javascript bundle, as is usual, allowing us  to de-duplicate common
        dependencies from our various applications. However, this approach
        means that we have to re-compile and release every single micro frontend
        in order to release a change to any individual part of the product.
        Just as with microservices, we've seen enough pain caused by such a
        <b>lockstep release process</b> that we would recommend strongly against
        this kind of approach to micro frontends.</p>

<p> Having gone to all of the trouble of dividing our application into
        discrete codebases that can be developed and tested independently, let's
        not re-introduce all of that coupling at the release stage. We should
        find a way to integrate our micro frontends at run-time, rather than at
        build-time.</p>
</section>

<section id="Run-timeIntegrationViaIframes">
<h3>Run-time integration via iframes</h3>

<p>One of the simplest approaches to composing applications together in
        the browser is the humble iframe. By their nature, iframes make it easy
        to build a page out of independent sub-pages. They also offer a good
        degree of isolation in terms of styling and global variables not
        interfering with each other.</p>

<pre class="code hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Feed me!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome to Feed me!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"micro-frontend-container"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
      <span class="hljs-keyword">const</span> microFrontendsByRoute = {
        <span class="hljs-string">'/'</span>: <span class="hljs-string">'https://browse.example.com/index.html'</span>,
        <span class="hljs-string">'/order-food'</span>: <span class="hljs-string">'https://order.example.com/index.html'</span>,
        <span class="hljs-string">'/user-profile'</span>: <span class="hljs-string">'https://profile.example.com/index.html'</span>,
      };

      <span class="hljs-keyword">const</span> iframe = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'micro-frontend-container'</span>);
      iframe.src = microFrontendsByRoute[<span class="hljs-built_in">window</span>.location.pathname];
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</pre>

<p>Just as with the
        <a href="https://martinfowler.com/articles/micro-frontends.html#Server-sideTemplateComposition">server-side includes option</a>,
        building a page out of iframes is not a new technique and perhaps does
        not seem that exciting. But if we revisit the chief benefits of micro
        frontends <a href="https://martinfowler.com/articles/micro-frontends.html#Benefits">listed earlier</a>, iframes mostly fit the
        bill, as long as we're careful about how we slice up the application and
        structure our teams.</p>

<p>We often see a lot of reluctance to choose iframes. While some of
        that reluctance does seem to be driven by a gut feel that iframes are a
        bit “yuck”, there are some good reasons that people avoid them. The easy
        isolation mentioned above does tend to make them less flexible than
        other options. It can be difficult to build integrations between
        different parts of the application, so they make routing, history, and
        deep-linking more complicated, and they present some extra challenges to
        making your page fully responsive.</p>
</section>

<section id="Run-timeIntegrationViaJavascript">
<h3>Run-time integration via JavaScript</h3>

<p>The next approach that we'll describe is probably the most flexible
        one, and the one that we see teams adopting most frequently. Each micro
        frontend is included onto the page using a <code>&lt;script&gt;</code> tag,
        and upon load exposes a global function as its entry-point. The
        container application then determines which micro frontend should be
        mounted, and calls the relevant function to tell a micro frontend when
        and where to render itself.</p>

<pre class="code hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Feed me!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome to Feed me!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- These scripts don't render anything immediately --&gt;</span>
    <span class="hljs-comment">&lt;!-- Instead they attach entry-point functions to `window` --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://browse.example.com/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://order.example.com/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://profile.example.com/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"micro-frontend-root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
      <span class="hljs-comment">// These global functions are attached to window by the above scripts</span>
      <span class="hljs-keyword">const</span> microFrontendsByRoute = {
        <span class="hljs-string">'/'</span>: <span class="hljs-built_in">window</span>.renderBrowseRestaurants,
        <span class="hljs-string">'/order-food'</span>: <span class="hljs-built_in">window</span>.renderOrderFood,
        <span class="hljs-string">'/user-profile'</span>: <span class="hljs-built_in">window</span>.renderUserProfile,
      };
      <span class="hljs-keyword">const</span> renderFunction = microFrontendsByRoute[<span class="hljs-built_in">window</span>.location.pathname];

      <span class="hljs-comment">// Having determined the entry-point function, we now call it,</span>
      <span class="hljs-comment">// giving it the ID of the element where it should render itself</span>
      renderFunction(<span class="hljs-string">'micro-frontend-root'</span>);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</pre>

<p>The above is obviously a primitive example, but it demonstrates the
        basic technique. Unlike with build-time integration, we can deploy each
        of the <code>bundle.js</code> files independently. And unlike with
        iframes, we have full flexibility to build integrations between our
        micro frontends however we like. We could extend the above code in many
        ways, for example to only download each JavaScript bundle as needed, or
        to pass data in and out when rendering a micro frontend.</p>

<p>The flexibility of this approach, combined with the independent
        deployability, makes it our default choice, and the one that we've seen
        in the wild most often. We'll explore it in more detail when we get into
        the <a href="https://martinfowler.com/articles/micro-frontends.html#TheExampleInDetail">full example.</a></p>
</section>

<section id="Run-timeIntegrationViaWebComponents">
<h3>Run-time integration via Web Components</h3>

<p>One variation to the previous approach is for each micro frontend to
        define an HTML custom element for the container to instantiate, instead
        of defining a global function for the container to call.</p>

<pre class="code hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Feed me!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome to Feed me!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- These scripts don't render anything immediately --&gt;</span>
    <span class="hljs-comment">&lt;!-- Instead they each define a custom element type --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://browse.example.com/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://order.example.com/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://profile.example.com/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"micro-frontend-root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
      <span class="hljs-comment">// These element types are defined by the above scripts</span>
      <span class="hljs-keyword">const</span> webComponentsByRoute = {
        <span class="hljs-string">'/'</span>: <span class="hljs-string">'micro-frontend-browse-restaurants'</span>,
        <span class="hljs-string">'/order-food'</span>: <span class="hljs-string">'micro-frontend-order-food'</span>,
        <span class="hljs-string">'/user-profile'</span>: <span class="hljs-string">'micro-frontend-user-profile'</span>,
      };
      <span class="hljs-keyword">const</span> webComponentType = webComponentsByRoute[<span class="hljs-built_in">window</span>.location.pathname];

      <span class="hljs-comment">// Having determined the right web component custom element type,</span>
      <span class="hljs-comment">// we now create an instance of it and attach it to the document</span>
      <span class="hljs-keyword">const</span> root = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'micro-frontend-root'</span>);
      <span class="hljs-keyword">const</span> webComponent = <span class="hljs-built_in">document</span>.createElement(webComponentType);
      root.appendChild(webComponent);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</pre>

<p>The end result here is quite similar to the previous example, the
        main difference being that you are opting in to doing things 'the web
        component way'. If you like the web component spec, and you like the
        idea of using capabilities that the browser provides, then this is a
        good option. If you prefer to define your own interface between the
        container application and micro frontends, then you might prefer the
        previous example instead.</p>
</section>
</section>

<section id="Styling">
<h2>Styling</h2>

<p>CSS as a language is inherently global, inheriting, and cascading,
      traditionally with no module system, namespacing or encapsulation. Some
      of those features do exist now, but browser support is often lacking. In a
      micro frontends landscape, many of these problems are exacerbated. For
      example, if one team's micro frontend has a stylesheet that says <code>h2 { color: black; }</code>,
      and another one says <code>h2 { color: blue; }</code>, and both these selectors are
      attached to the same page, then someone is going to be disappointed! This
      is not a new problem, but it's made worse by the fact that these selectors
      were written by different teams at different times, and the code is
      probably split across separate repositories, making it more difficult to
      discover.</p>

<p>Over the years, many approaches have been invented to make CSS more
      manageable. Some choose to use a strict naming convention, such as
      <a href="http://getbem.com/">BEM</a>, to ensure selectors only apply where intended.
      Others, preferring not to rely on developer discipline alone, use a
      pre-processor such as <a href="https://sass-lang.com/">SASS</a>, whose selector
      nesting can be used as a form of namespacing. A newer approach is to apply
      all styles programatically with <a href="https://github.com/css-modules/css-modules">CSS modules</a>
      or one of the various <a href="https://mxstbr.com/thoughts/css-in-js/">CSS-in-JS</a> libraries,
      which ensures that styles are directly applied only in the places the
      developer intends. Or for a more platform-based approach,
      <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM">shadow DOM</a> also offers style isolation.</p>

<p>The approach that you pick does not matter all that much, as long as
      you find a way to ensure that developers can write their styles
      independently of each other, and have confidence that their code will
      behave predictably when composed together into a single application.</p>
</section>

<section id="SharedComponentLibraries">
<h2>Shared component libraries</h2>

<p>We mentioned above that visual consistency across micro frontends is
      important, and one approach to this is to develop a library of shared,
      re-usable UI components. In general we believe that this a good idea,
      although it is difficult to do well. The main benefits of creating such a
      library are reduced effort through re-use of code, and visual consistency.
      In addition, your component library can serve as a living styleguide, and
      it can be a great point of collaboration between developers and
      designers.</p>

<p>One of the easiest things to get wrong is to create too many of these
      components, too early. It is tempting to create a <a href="https://martinfowler.com/bliki/FoundationFramework.html">Foundation Framework</a>, with all of the common visuals that will be
      needed across all applications. However, experience tells us that it's
      difficult, if not impossible, to guess what the components' APIs should be
      before you have real-world usage of them, which results in a lot of churn
      in the early life of a component. For that reason, we prefer to let teams
      create their own components within their codebases as they need them, even
      if that causes some duplication initially. Allow the patterns to emerge
      naturally, and once the component's API has become obvious, you can <a href="https://martinfowler.com/bliki/HarvestedFramework.html">harvest</a> the duplicate code into a shared library
      and be confident that you have something proven.</p>

<p>The most obvious candidates for sharing are “dumb” visual primitives
      such as icons, labels, and buttons. We can also share more complex
      components which might contain a significant amount of UI logic, such as
      an auto-completing, drop-down search field. Or a sortable, filterable,
      paginated table. However, be careful to ensure that your shared components
      contain only UI logic, and no business or domain logic. When domain logic
      is put into a shared library it creates a high degree of coupling across
      applications, and increases the difficulty of change. So, for example, you
      usually should not try to share a <code>ProductTable</code>, which would contain all
      sorts of assumptions about what exactly a “product” is and how one should
      behave. Such domain modelling and business logic belongs in the
      application code of the micro frontends, rather than in a shared
      library.</p>

<p>As with any shared internal library, there are some tricky questions
      around its ownership and governance. One model is to say that as a shared
      asset, “everyone” owns it, though in practice this usually means that <i>no
      one</i> owns it. It can quickly become a hodge-podge of inconsistent code
      with no clear conventions or technical vision. At the other extreme, if
      development of the shared library is completely centralised, there will be
      a big disconnect between the people who create the components and the
      people who consume them. The best models that we've seen are ones where
      anyone can contribute to the library, but there is a
      <a href="https://martinfowler.com/bliki/ServiceCustodian.html">custodian</a> (a
      person or a team) who is responsible for ensuring the quality,
      consistency, and validity of those contributions. The job of maintaining
      the shared library requires strong technical skills, but also the people
      skills necessary to cultivate collaboration across many teams.</p>
</section>

<section id="Cross-applicationCommunication">
<h2>Cross-application communication</h2>

<p>One of the most common questions regarding micro frontends is how to
      let them talk to each other. In general, we recommend having them
      communicate as little as possible, as it often reintroduces the sort of
      inappropriate coupling that we're seeking to avoid in the first place.</p>

<p>That said, some level of cross-app communication is often needed.
      <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events">Custom events</a> allow micro frontends to
      communicate indirectly, which is a good way to minimise direct coupling,
      though it does make it harder to determine and enforce the contract that
      exists between micro frontends. Alternatively, the React model of passing
      callbacks and data downwards (in this case downwards from the container
      application to the micro frontends) is also a good solution that makes the
      contract more explicit. A third alternative is to use the address bar as a
      communication mechanism, which we'll explore
      <a href="https://martinfowler.com/articles/micro-frontends.html#Cross-applicationCommunicationViaRouting"> in more detail later</a>.</p>

<aside class="sidebar">
<p>If you are using redux, the usual approach is to have a single,
        global, shared store for the entire application. However, if each micro
        frontend is supposed to be its own self-contained application, then it
        makes sense for each one to have its own redux store. The redux docs
        even mention <a href="https://redux.js.org/faq/store-setup#can-or-should-i-create-multiple-stores-can-i-import-my-store-directly-and-use-it-in-components-myself">"isolating a Redux app as a
        component in a bigger application"</a> as a valid reason to have
        multiple stores.</p>
</aside>

<p>Whatever approach we choose, we want our micro frontends to communicate
      by sending messages or events to each other, and avoid having any shared
      state. Just like sharing a database across microservices, as soon as we
      share our data structures and domain models, we create massive amounts of
      coupling, and it becomes extremely difficult to make changes.</p>

<p>As with styling, there are several different approaches that can work
      well here. The most important thing is to think long and hard about what
      sort of coupling you're introducing, and how you'll maintain that contract
      over time. Just as with integration between microservices, you won't be
      able to make breaking changes to your integrations without having a
      coordinated upgrade process across different applications and teams.</p>

<p>You should also think about how you'll automatically verify that the
      integration does not break. Functional testing is one approach, but we
      prefer to limit the number of functional tests we write due to the cost of
      implementing and maintaining them. Alternatively you could implement some
      form of <a href="https://martinfowler.com/articles/consumerDrivenContracts.html">consumer-driven contracts</a>,
      so that each micro frontend can specify what it requires of other micro
      frontends, without needing to actually integrate and run them all in a
      browser together.</p>
</section>

<section id="BackendCommunication">
<h2>Backend communication</h2>

<p>If we have separate teams working independently on frontend
      applications, what about backend development? We believe strongly in the
      value of full-stack teams, who own their application's development from
      visual code all the way through to API development, and database and
      infrastructure code. One pattern that helps here is the
      <a href="https://samnewman.io/patterns/architectural/bff/">BFF</a> pattern, where
      each frontend application has a corresponding backend whose purpose is
      solely to serve the needs of that frontend. While the BFF pattern might
      originally have meant dedicated backends for each frontend channel (web,
      mobile, etc), it can easily be extended to mean a backend for each micro
      frontend.</p>

<p>There are a lot of variables to account for here. The BFF might be self
      contained with its own business logic and database, or it might just be an
      aggregator of downstream services. If there are downstream services, it
      may or may not make sense for the team that owns the micro frontend and
      its BFF, to also own some of those services. If the micro frontend has
      only one API that it talks to, and that API is fairly stable, then there
      may not be much value in building a BFF at all. The guiding principle here is
      that the team building a particular micro frontend shouldn't have to wait
      for other teams to build things for them. So if every new feature added to
      a micro frontend also requires backend changes, that's a strong case for a
      BFF, owned by the same team.</p>

<div class="figure " id="bff.png"><img alt="A diagram showing three pairs of frontends / backends. The first backend talks only to its own database. The other two backends talk to shared downstream services. Both approaches are valid." src="./Micro Frontends_files/bff.png">
<p class="photoCaption">Figure 7: There
are many different ways to structure your frontend/backend relationships
      </p>
</div>

<div class="clear"></div>

<p>Another common question is, how should the user of a micro frontend
      application be authenticated and authorised with the server? Obviously our
      customers should only have to authenticate themselves once, so auth
      usually falls firmly in the category of cross-cutting concerns that should
      be owned by the container application. The container probably has some
      sort of login form, through which we obtain some sort of token. That token
      would be owned by the container, and can be injected into each micro
      frontend on initialisation. Finally, the micro frontend can send the token
      with any request that it makes to the server, and the server can do
      whatever validation is required.</p>
</section>

<section id="Testing">
<h2>Testing</h2>

<p>We don't see much difference between monolithic frontends and micro
      frontends when it comes to testing. In general, whatever strategies you
      are using to test a monolithic frontend can be reproduced across each
      individual micro frontend. That is, each micro frontend should have its
      own comprehensive suite of automated tests that ensure the quality and
      correctness of the code.</p>

<p>The obvious gap would then be integration testing of the various micro
      frontends with the container application. This can be done using your
      preferred choice of functional/end-to-end testing tool (such as Selenium
      or Cypress), but don't take things too far; functional tests should only
      cover aspects that cannot be tested at a lower level of the <a href="https://martinfowler.com/bliki/TestPyramid.html">Test Pyramid</a>. By that we mean, use unit tests to cover your
      low-level business logic and rendering logic, and then use functional
      tests just to validate that the page is assembled correctly. For example,
      you might load up the fully-integrated application at a particular URL,
      and assert that the hard-coded title of the relevant micro frontend is
      present on the page.</p>

<p>If there are user journeys that span across micro frontends, then you
      could use functional testing to cover those, but keep the functional tests
      focussed on validating the integration of the frontends, and not the
      internal business logic of each micro frontend, which should have already
      been covered by unit tests.
      <a href="https://martinfowler.com/articles/micro-frontends.html#Cross-applicationCommunication"> As mentioned above,</a>
      consumer-driven contracts can help to directly specify the interactions
      that occur between micro frontends without the flakiness of integration
      environments and functional testing.</p>
</section>

<section id="TheExampleInDetail">
<h2>The example in detail</h2>

<p>Most of the rest of this article will be a detailed explanation of just
      one way that our example application can be implemented. We'll focus
      mostly on how the container application and the micro frontends
      <a href="https://martinfowler.com/articles/micro-frontends.html#Run-timeIntegrationViaJavascript">integrate together using JavaScript</a>,
      as that's probably the most interesting and complex part. You can see the
      end result deployed live at <a href="https://demo.microfrontends.com/">https://demo.microfrontends.com</a>,
      and the full source code can be seen on <a href="https://github.com/micro-frontends-demo">Github</a>.</p>

<div class="figure " id="screenshot-browse.png"><img alt="A screenshot of the &#39;browse&#39; landing page of the full micro frontends demo application" src="./Micro Frontends_files/screenshot-browse.png">
<p class="photoCaption">Figure 8: The 'browse' landing page of
the full micro frontends demo application</p>
</div>

<div class="clear"></div>

<p>The demo is all built using React.js, so it's worth calling out that
      React does <i>not</i> have a monopoly on this architecture. Micro frontends can
      be implemented with with many different tools or frameworks. We chose
      React here because of its popularity and because of our own familiarity
      with it.</p>

<section id="TheContainer">
<h3>The container</h3>

<p>We'll start with <a href="https://github.com/micro-frontends-demo/container">the container</a>, as
        it's the entry point for our customers. Let's see what we can learn
        about it from its <code>package.json</code>:</p>

<pre class="code hljs json">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"@micro-frontends-demo/container"</span>,
  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"Entry point and container for a micro frontends demo"</span>,
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"start"</span>: <span class="hljs-string">"PORT=3000 react-app-rewired start"</span>,
    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"react-app-rewired build"</span>,
    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"react-app-rewired test"</span>
  },
  <span class="hljs-attr">"dependencies"</span>: {
    <span class="hljs-attr">"react"</span>: <span class="hljs-string">"^16.4.0"</span>,
    <span class="hljs-attr">"react-dom"</span>: <span class="hljs-string">"^16.4.0"</span>,
    <span class="hljs-attr">"react-router-dom"</span>: <span class="hljs-string">"^4.2.2"</span>,
    <span class="hljs-attr">"react-scripts"</span>: <span class="hljs-string">"^2.1.8"</span>
  },
  <span class="hljs-attr">"devDependencies"</span>: {
    <span class="hljs-attr">"enzyme"</span>: <span class="hljs-string">"^3.3.0"</span>,
    <span class="hljs-attr">"enzyme-adapter-react-16"</span>: <span class="hljs-string">"^1.1.1"</span>,
    <span class="hljs-attr">"jest-enzyme"</span>: <span class="hljs-string">"^6.0.2"</span>,
    <span class="hljs-attr">"react-app-rewire-micro-frontends"</span>: <span class="hljs-string">"^0.0.1"</span>,
    <span class="hljs-attr">"react-app-rewired"</span>: <span class="hljs-string">"^2.1.1"</span>
  },
  <span class="hljs-attr">"config-overrides-path"</span>: <span class="hljs-string">"node_modules/react-app-rewire-micro-frontends"</span>
}
</pre>

<aside class="sidebar">
<p> In version 1 of <code>react-scripts</code> it was possible to have
          multiple applications coexist on a single page without conflicts, but
          version 2 uses some webpack features that cause errors when two or
          more apps try to render themselves on the one page. For this reason we
          use <code>react-app-rewired</code> to override some of the internal
          webpack config of <code>react-scripts</code>. This fixes those errors,
          and lets us keep relying on <code>react-scripts</code> to manage our
          build tooling for us.</p>
</aside>

<p>From the dependencies on <code>react</code> and <code>react-scripts</code>,
        we can conclude that it's a React.js application created with
          <a href="https://facebook.github.io/create-react-app/"><code>create-react-app</code></a>.
        More interesting is what's <i>not</i> there: any mention of the
        micro frontends that we're going to compose together to form our final
        application. If we were to specify them here as library dependencies,
        we'd be heading down the path of build-time integration, which
        <a href="https://martinfowler.com/articles/micro-frontends.html#Build-timeIntegration">as mentioned previously</a> tends to
        cause problematic coupling in our release cycles.</p>

<p>To see how we select and display a micro frontend, let's look at
        <code>App.js</code>. We use <a href="https://reacttraining.com/react-router/">React Router</a>
        to match the current URL against a predefined list of routes, and render
        a corresponding component:</p>

<pre class="code hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Browse}</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/restaurant/:id"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Restaurant}</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/random"</span> <span class="hljs-attr">render</span>=<span class="hljs-string">{Random}</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span>
</pre>

<p>The <code>Random</code> component is not that interesting - it just redirects
        the page to a randomly selected restaurant URL. The <code>Browse</code> and
        <code>Restaurant</code> components look like this:</p>

<pre class="code hljs dust"><span class="xml">const Browse = (</span><span class="hljs-template-variable">{ history }</span><span class="xml">) =&gt; (
  <span class="hljs-tag">&lt;<span class="hljs-name">MicroFrontend</span> <span class="hljs-attr">history</span>=</span></span><span class="hljs-template-variable">{history}</span><span class="xml"><span class="hljs-tag"> <span class="hljs-attr">name</span>=<span class="hljs-string">"Browse"</span> <span class="hljs-attr">host</span>=</span></span><span class="hljs-template-variable">{browseHost}</span><span class="xml"><span class="hljs-tag"> /&gt;</span>
);
const Restaurant = (</span><span class="hljs-template-variable">{ history }</span><span class="xml">) =&gt; (
  <span class="hljs-tag">&lt;<span class="hljs-name">MicroFrontend</span> <span class="hljs-attr">history</span>=</span></span><span class="hljs-template-variable">{history}</span><span class="xml"><span class="hljs-tag"> <span class="hljs-attr">name</span>=<span class="hljs-string">"Restaurant"</span> <span class="hljs-attr">host</span>=</span></span><span class="hljs-template-variable">{restaurantHost}</span><span class="xml"><span class="hljs-tag"> /&gt;</span>
);
</span></pre>

<p>In both cases, we render a <code>MicroFrontend</code> component. Aside from the
        history object (which will become important later), we specify the
        unique name of the application, and the host from which its bundle can
        be downloaded. This config-driven URL will be something like
        <code>http://localhost:3001</code> when running locally, or
        <code>https://browse.demo.microfrontends.com</code> in production.</p>

<p>Having selected a micro frontend in <code>App.js</code>, now we'll
        render it in <code>MicroFrontend.js</code>, which is just another React
        component:</p>

<pre class="code javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MicroFrontend</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">this.props.name</span>}<span class="hljs-attr">-container</span>`} /&gt;</span>;
  }
}
</span></pre>

<p class="code-remark">This is not the entire class, we'll be seeing more of its
          methods soon.</p>

<p>When rendering, all we do is put a container element on the page,
        with an ID that's unique to the micro frontend. This is where we'll
        tell our micro frontend to render itself. We use React's
        <code>componentDidMount</code> as the trigger for downloading and mounting the
        micro frontend:</p>

<aside class="sidebar">
<p><code>componentDidMount</code> is a lifecycle method of React
          components, which is called by the framework just after an instance of
          our component has been 'mounted' into the DOM for the first time.
          </p>
</aside>

<p class="code-label">class MicroFrontend…
</p>

<pre class="code hljs javascript">  componentDidMount() {
    <span class="hljs-keyword">const</span> { name, host } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">const</span> scriptId = <span class="hljs-string">`micro-frontend-script-<span class="hljs-subst">${name}</span>`</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.getElementById(scriptId)) {
      <span class="hljs-keyword">this</span>.renderMicroFrontend();
      <span class="hljs-keyword">return</span>;
    }

    fetch(<span class="hljs-string">`<span class="hljs-subst">${host}</span>/asset-manifest.json`</span>)
      .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())
      .then(<span class="hljs-function"><span class="hljs-params">manifest</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);
        script.id = scriptId;
        script.src = <span class="hljs-string">`<span class="hljs-subst">${host}</span><span class="hljs-subst">${manifest[<span class="hljs-string">'main.js'</span>]}</span>`</span>;
        script.onload = <span class="hljs-keyword">this</span>.renderMicroFrontend;
        <span class="hljs-built_in">document</span>.head.appendChild(script);
      });
  }
</pre>

<aside class="sidebar">
<p>We have to fetch the script's URL from an asset manifest file,
          because <code>react-scripts</code> outputs compiled JavaScript files
          that have hashes in their filename to facilitate caching.</p>
</aside>

<p>First we check if the relevant script, which has a unique ID, has
        already been downloaded, in which case we can just render it
        immediately. If not, we fetch the <code>asset-manifest.json</code> file
        from the appropriate host, in order to look up the full URL of the main
        script asset. Once we've set the script's URL, all that's left is to attach it to the
        document, with an <code>onload</code> handler that renders the micro frontend:</p>

<p class="code-label">class MicroFrontend…
</p>

<pre class="code hljs javascript">  renderMicroFrontend = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> { name, history } = <span class="hljs-keyword">this</span>.props;

    <span class="hljs-built_in">window</span>[<span class="hljs-string">`render<span class="hljs-subst">${name}</span>`</span>](<span class="hljs-string">`<span class="hljs-subst">${name}</span>-container`</span>, history);
    <span class="hljs-comment">// E.g.: window.renderBrowse('browse-container', history);</span>
  };
</pre>

<p>In the above code we're calling a global function called something
        like <code>window.renderBrowse</code>, which was put there by the script
        that we just downloaded. We pass it the ID of the <code>&lt;main&gt;</code>
        element where the micro frontend should render itself, and a <code>history</code>
        object, which we'll explain soon. <b>The signature of this global
        function is the key contract between the container application and the
        micro frontends</b>. This is where any communication or integration
        should happen, so keeping it fairly lightweight makes it easy to
        maintain, and to add new micro frontends in the future. Whenever we want
        to do something that would require a change to this code, we should
        think long and hard about what it means for the coupling of our
        codebases, and the maintenance of the contract.</p>

<p>There's one final piece, which is handling clean-up. When our
        <code>MicroFrontend</code> component un-mounts (is removed from the DOM),
        we want to un-mount the relevant micro frontend too. There is a
        corresponding global function defined by each micro frontend for this
        purpose, which we call from the appropriate React lifecycle method:</p>

<p class="code-label">class MicroFrontend…
</p>

<pre class="code hljs javascript">  componentWillUnmount() {
    <span class="hljs-keyword">const</span> { name } = <span class="hljs-keyword">this</span>.props;

    <span class="hljs-built_in">window</span>[<span class="hljs-string">`unmount<span class="hljs-subst">${name}</span>`</span>](<span class="hljs-string">`<span class="hljs-subst">${name}</span>-container`</span>);
  }
</pre>

<p>In terms of its own content, all that the container renders directly
        is the top-level header and navigation bar of the site, as those are
        constant across all pages. The CSS for those elements has been written
        carefully to ensure that it will only style elements within the header,
        so it shouldn't conflict with any styling code within the micro frontends.</p>

<p>And that's the end of the container application! It's fairly
        rudimentary, but this gives us a shell that can dynamically download our
        micro frontends at runtime, and glue them together into something
        cohesive on a single page. Those micro frontends can be independently
        deployed all the way to production, without ever making a change to any
        other micro frontend, or to the container itself.</p>
</section>

<section id="TheMicroFrontends">
<h3>The micro frontends</h3>

<p>The logical place to continue this story is with the global render
        function we keep referring to. The home page of our application is a
        filterable list of restaurants, whose entry point looks like this:</p>

<pre class="code javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>;
<span class="hljs-keyword">import</span> registerServiceWorker <span class="hljs-keyword">from</span> <span class="hljs-string">'./registerServiceWorker'</span>;

<span class="hljs-built_in">window</span>.renderBrowse = <span class="hljs-function">(<span class="hljs-params">containerId, history</span>) =&gt;</span> {
  ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> <span class="hljs-attr">history</span>=<span class="hljs-string">{history}</span> /&gt;</span>, document.getElementById(containerId));
  registerServiceWorker();
};

window.unmountBrowse = containerId =&gt; {
  ReactDOM.unmountComponentAtNode(document.getElementById(containerId));
};
</span></pre>

<p>Usually in React.js applications, the call to <code>ReactDOM.render</code> would
        be at the top-level scope, meaning that as soon as this script file is
        loaded, it immediately begins rendering into a hard-coded DOM element.
        For this application, we need to be able control both when and where the
        rendering happens, so we wrap it in a function that receives the DOM
        element's ID as a parameter, and we attach that function to the global
        <code>window</code> object. We can also see the corresponding un-mounting function
        that is used for clean-up.</p>

<p>While we've already seen how this function is called when the micro
        frontend is integrated into the whole container application, one of the
        biggest criteria for success here is that we can develop and run the
        micro frontends independently. So each micro frontend also has its own
        <code>index.html</code> with an inline script to render the application in a
        “standalone” mode, outside of the container:</p>

<pre class="code hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Restaurant order<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
      <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">window</span>.renderRestaurant(<span class="hljs-string">'container'</span>);
      };
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</pre>

<div class="figure " id="screenshot-order.png"><img alt="A screenshot of the &#39;order&#39; page running as a standalone application outside of the container" src="./Micro Frontends_files/screenshot-order.png">
<p class="photoCaption">Figure 9: Each micro frontend
        can be run as a standalone application outside of the container.
        </p>
</div>

<div class="clear"></div>

<p>From this point onwards, the micro frontends are mostly just plain
        old React apps. The <a href="https://github.com/micro-frontends-demo/browse">'browse'</a> application
        fetches the list of restaurants from the backend, provides <code>&lt;input&gt;</code>
        elements for searching and filtering the restaurants, and renders React
        Router <code>&lt;Link&gt;</code> elements, which navigate to a specific
        restaurant. At that point we would switch over to the second,
        <a href="https://github.com/micro-frontends-demo/restaurant-order">'order'</a> micro frontend, which renders a
        single restaurant with its menu.</p>

<div class="figure " id="demo-architecture.png"><img alt="An architecture diagram that shows the sequence of steps for navigation, as described above" src="./Micro Frontends_files/demo-architecture.png">
<p class="photoCaption">Figure 10: These micro
        frontends interact only via route changes, not directly</p>
</div>

<div class="clear"></div>

<p>The final thing worth mentioning about our micro frontends is that
        they both use <code>styled-components</code> for all of their styling. This
        CSS-in-JS library makes it easy to associate styles with specific
        components, so we are guaranteed that a micro frontend's styles will not
        leak out and effect the container, or another micro frontend.</p>
</section>

<section id="Cross-applicationCommunicationViaRouting">
<h3>Cross-application communication via routing</h3>

<p>We <a href="https://martinfowler.com/articles/micro-frontends.html#Cross-applicationCommunication">mentioned earlier</a>
        that cross-application communication should be kept to a minimum. In
        this example, the only requirement we have is that the browsing page
        needs to tell the restaurant page which restaurant to load. Here we will
        see how we can use client-side routing to solve this problem.</p>

<p>All three React applications involved here are using React Router for
        declarative routing, but initialised in two slightly different ways. For
        the container application, we create a <code>&lt;BrowserRouter&gt;</code>,
        which internally will instantiate a <code>history</code> object. This is
        the same <code>history</code> object that we've been glossing over
        previously. We use this object to manipulate the client-side history,
        and we can also use it to link multiple React Routers together. Inside
        our micro frontends, we initialise the Router like this:</p>

<pre class="code javascript hljs">&lt;Router history={<span class="hljs-keyword">this</span>.props.history}&gt;
</pre>

<p>In this case, rather than letting React Router instantiate another
        history object, we provide it with the instance that was passed in by the
        container application. All of the <code>&lt;Router&gt;</code> instances are
        now connected, so route changes triggered in any of them will be reflected
        in all of them. This gives us an easy way to pass “parameters” from one
        micro frontend to another, via the URL. For example in the browse micro
        frontend, we have a link like this:</p>

<pre class="code javascript hljs">&lt;Link to={<span class="hljs-string">`/restaurant/<span class="hljs-subst">${restaurant.id}</span>`</span>}&gt;
</pre>

<p>When this link is clicked, the route will be updated in the container,
        which will see the new URL and determine that the restaurant micro
        frontend should be mounted and rendered. That micro frontend's own
        routing logic will then extract the restaurant ID from the URL and
        render the right information.</p>

<p>Hopefully this example flow shows the flexibility and power of the
        humble URL. Aside from being useful for sharing and bookmarking, in this
        particular architecture it can be a useful way to communicate intent
        across micro frontends. Using the page URL for this purpose ticks many
        boxes:</p>

<ul>
<li>Its structure is a well-defined, open standard</li>

<li>It's globally accessible to any code on the page</li>

<li>Its limited size encourages sending only a small amount of data</li>

<li>It's user-facing, which encourages a structure that models the
          domain faithfully</li>

<li>It's declarative, not imperative. I.e. "this is where we are",
          rather than "please do this thing"</li>

<li>It forces micro frontends to communicate indirectly, and not know
          about or depend on each other directly</li>
</ul>

<p>When using routing as our mode of communication between micro
        frontends, the routes that we choose constitute a <b>contract</b>. In
        this case, we've set in stone the idea that a restaurant can be viewed
        at <code>/restaurant/:restaurantId</code>, and we can't change that
        route without updating all applications that refer to it. Given the
        importance of this contract, we should have automated tests that check
        that the contract is being adhered to.</p>
</section>

<section id="CommonContent">
<h3>Common content</h3>

<p>While we want our teams and our micro frontends to be as independent
        as possible, there are some things that should be common. We wrote earlier
        about how <a href="https://martinfowler.com/articles/micro-frontends.html#SharedComponentLibraries">shared component libraries</a>
        can help with consistency across micro frontends, but for this small demo
        a component library would be overkill. So instead, we have a small
        <a href="https://github.com/micro-frontends-demo/content">repository of common content</a>, including
        images, JSON data, and CSS, which are served over the network to all
        micro frontends.</p>

<p>There's another thing that we can choose to share across micro
        frontends: library dependencies. As we will <a href="https://martinfowler.com/articles/micro-frontends.html#PayloadSize">describe
        shortly</a>, duplication of dependencies is a common drawback of micro
        frontends. Even though sharing those dependencies across applications
        comes with its own set of difficulties, for this demo application it's
        worth talking about how it can be done.</p>

<p>The first step is to choose which dependencies to share. A quick
        analysis of our compiled code showed that about 50% of the bundles was
        contributed by <code>react</code> and <code>react-dom</code>. In addition
        to their size, these two libraries are our most 'core' dependencies, so
        we know that all micro frontends can benefit from having them extracted.
        Finally, these are stable, mature libraries, which usually introduce
        breaking changes across two major versions, so cross-application upgrade
        efforts should not be too difficult.</p>

<p>As for the actual extraction, all we need to do is mark the libraries
        as <a href="https://webpack.js.org/configuration/externals/">externals</a> in our webpack
        config, which we can do with a rewiring similar to the one
        <a href="https://martinfowler.com/articles/micro-frontends.html#TheContainer">described earlier</a>.</p>

<pre class="code hljs javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">config, env</span>) =&gt;</span> {
  config.externals = {
    <span class="hljs-attr">react</span>: <span class="hljs-string">'React'</span>,
    <span class="hljs-string">'react-dom'</span>: <span class="hljs-string">'ReactDOM'</span>
  }
  <span class="hljs-keyword">return</span> config;
};
</pre>

<p>Then we add a couple of <code>script</code> tags to each <code>index.html</code>
        file, to fetch the two libraries from our shared content server.</p>

<pre class="code hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>
    You need to enable JavaScript to run this app.
  <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"%REACT_APP_CONTENT_HOST%/react.prod-16.8.6.min.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"%REACT_APP_CONTENT_HOST%/react-dom.prod-16.8.6.min.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</pre>

<p>Sharing code across teams is always a tricky thing to do well. We
        need to ensure that we only share things that we genuinely want to be
        common, and that we want to change in multiple places at once. However,
        if we're careful about what we do share and what we don't, then there
        are real benefits to be gained.</p>
</section>

<section id="Infrastructure">
<h3>Infrastructure</h3>

<p>The application is hosted on AWS, with core infrastructure
        (S3 buckets, CloudFront distributions, domains, certificates, etc),
        provisioned all at once using a <a href="https://github.com/micro-frontends-demo/infra">centralised
        repository</a> of Terraform code. Each micro frontend then has its
        own source repository with its own continuous deployment pipeline on
        <a href="https://travis-ci.org/micro-frontends-demo/">Travis CI</a>, which builds, tests, and deploys
        its static assets into those S3 buckets. This balances the convenience
        of centralised infrastructure management with the flexibility of
        independent deployability.</p>

<p>Note that each micro frontend (and the container) gets its own bucket.
        This means that it has free reign over what goes in there, and we don't
        need to worry about object name collisions, or conflicting access
        management rules, from another team or application.</p>
</section>
</section>

<section id="Downsides">
<h2>Downsides</h2>

<p>At the start of this article, we mentioned that there are tradeoffs
      with micro frontends, as there are with any architecture. The benefits
      that we've mentioned do come with a cost, which we'll cover here.</p>

<section id="PayloadSize">
<h3>Payload size</h3>

<p>Independently-built JavaScript bundles can cause duplication of common
        dependencies, increasing the number of bytes we have to send over the
        network to our end users. For example, if every micro frontend includes
        its own copy of React, then we're forcing our customers to download React
        <i>n</i> times. There is a <a href="https://developers.google.com/web/fundamentals/performance/why-performance-matters/">direct relationship</a>
        between page performance and user engagement/conversion, and much of the
        world runs on internet infrastructure much slower than those in
        highly-developed cities are used to, so we have many reasons to care
        about download sizes.</p>

<p>This issue is not easy to solve. There is an inherent tension between
        our desire to let teams compile their applications independently so that
        they can work autonomously, and our desire to build our applications in
        such a way that they can share common dependencies. One approach is to
        externalise common dependencies from our compiled bundles,
        <a href="https://martinfowler.com/articles/micro-frontends.html#CommonContent"> as we described</a> for the demo application.
        As soon as we go down this path though, we've re-introduced some
        build-time coupling to our micro frontends. Now there is an implicit
        contract between them which says, “we all must use these exact versions
        of these dependencies”. If there is a breaking change in a dependency,
        we might end up needing a big coordinated upgrade effort and a one-off
        lockstep release event. This is everything we were trying to avoid with
        micro frontends in the first place!</p>

<p>This inherent tension is a difficult one, but it's not all bad news.
        Firstly, even if we choose to do nothing about duplicate
        dependencies, it's possible that each individual page will still load
        faster than if we had built a single monolithic frontend. The reason is
        that by compiling each page independently, we have effectively
        implemented our own form of code splitting. In classic monoliths, when
        any page in the application is loaded, we often download the source code
        and dependencies of every page all at once. By building independently,
        any single page-load will only download the source and dependencies of
        that page. This may result in faster initial page-loads, but slower
        subsequent navigation as users are forced to re-download the same
        dependencies on each page. If we are disciplined in not bloating our
        micro frontends with unnecessary dependencies, or if we know that users
        generally stick to just one or two pages within the application, we may
        well achieve a net <i>gain</i> in performance terms, even with
        duplicated dependencies.</p>

<p>There are lots of “may’s” and “possibly’s” in the previous paragraph,
        which highlights the fact that every application will always have its
        own unique performance characteristics. If you want to know for sure
        what the performance impacts will be of a particular change, there is no
        substitute for taking real-world measurements, ideally in production.
        We've seen teams agonise over a few extra kilobytes of JavaScript, only
        to go and download many megabytes of high-resolution images, or run
        expensive queries against a very slow database. So while it's important
        to consider the performance impacts of every architectural decision,
        be sure that you know where the real bottlenecks are.</p>
</section>

<section id="EnvironmentDifferences">
<h3>Environment differences</h3>

<p>We should be able to develop a single micro frontend without needing
        to think about all of the other micro frontends being developed by other
        teams. We may even be able to run our micro frontend in a “standalone”
        mode, on a blank page, rather than inside the container application that
        will house it in production. This can make development a lot simpler,
        especially when the real container is a complex, legacy codebase, which
        is often the case when we're using micro frontends to do a gradual
        migration from old world to new. However, there are risks associated
        with developing in an environment that is quite different to production.
        If our development-time container behaves differently than the
        production one, then we may find that our micro frontend is broken, or
        behaves differently when we deploy to production. Of particular concern
        are global styles that may be brought along by the container, or by
        other micro frontends.</p>

<p>The solution here is not that different to any other situation where
        we have to worry about environmental differences. If we're developing
        locally in an environment that is not production-like, we need to ensure
        that we regularly integrate and deploy our micro frontend to
        environments that <i>are</i> like production, and we should do testing
        (manual and automated) in these environments to catch integration issues
        as early as possible. This will not completely solve the problem, but
        ultimately it's another tradeoff that we have to weigh up: is the
        productivity boost of a simplified development environment worth the
        risk of integration issues? The answer will depend on the project!</p>
</section>

<section id="OperationalAndGovernanceComplexity">
<h3>Operational and governance complexity</h3>

<p>The final downside is one with a direct parallel to microservices.
        As a more distributed architecture, micro frontends will inevitably lead
        to having more <i>stuff</i> to manage - more repositories, more tools,
        more build/deploy pipelines, more servers, more domains, etc. So before
        adopting such an architecture there are a few questions you should
        consider:</p>

<ul>
<li>Do you have enough automation in place to feasibly provision and
          manage the additional required infrastructure?</li>

<li>Will your frontend development, testing, and release processes
          scale to many applications?</li>

<li>Are you comfortable with decisions around tooling and development
          practices becoming more decentralised and less controllable?</li>

<li>How will you ensure a minimum level of quality, consistency, or
          governance across your many independent frontend codebases?</li>
</ul>

<p>We could probably fill another entire article discussing these
        topics. The main point we wish to make is that when you choose micro
        frontends, by definition you are opting to create many small things
        rather than one large thing. You should consider whether you have the
        technical and organisational maturity required to adopt such an approach
        without creating chaos.</p>
</section>
</section>

<section id="Conclusion">
<h2>Conclusion</h2>

<p>As frontend codebases continue to get more complex over the years, we
      see a growing need for more scalable architectures. We need to be able to
      draw clear boundaries that establish the right levels of coupling and
      cohesion between technical and domain entities. We should be able to scale
      software delivery across independent, autonomous teams.</p>

<p> While far from the only approach, we have seen many real-world
      cases where micro frontends deliver these benefits, and we've been able
      to apply the technique gradually over time to legacy codebases as well as
      new ones. Whether micro frontends are the right approach for you and your
      organiation or not, we can only hope that this will be part of a
      continuing trend where frontend engineering and architecture is treated
      with the seriousness that we know it deserves.</p>
</section>

<hr class="bodySep">
</div>

<div class="appendix">
<section id="Acknowledgements">
<h2>Acknowledgements</h2>

<p>Huge thanks to Charles Korn, Andy Marks, and Willem Van Ketwich for
      their thorough reviews and detailed feedback.</p>

<p>Thanks also to Bill Codding, Michael Strasser, and Shirish Padalkar
      for their input given on the ThoughtWorks internal mailing list.</p>

<p>Thanks to Martin Fowler for his feedback as well, and for giving this
      this article a home here on his website.</p>

<p>And finally, thanks to Evan Bottcher and Liauw Fendy for their
      encouragement and support.</p>
</section>
</div>

<div class="appendix">
<h2 id="SignificantRevisions">Significant Revisions</h2>

<p><i>19 June 2019: </i>Published final installment on downsides</p>

<p><i>17 June 2019: </i>Published installment with the example</p>

<p><i>13 June 2019: </i>Published installment with sections from styling
  to testing.</p>

<p><i>11 June 2019: </i>Published installment on integration approaches.</p>

<p><i>10 June 2019: </i>Published first installment: covering benefits</p>
</div>
</main>

<nav id="bottom-navmenu" style="display: none;">
<nav class="navmenu">
<div class="nav-head">  <div class="search">
    <!-- SiteSearch Google -->
    <form method="GET" action="https://www.google.com/search">
      <input type="hidden" name="ie" value="UTF-8">
      <input type="hidden" name="oe" value="UTF-8">
      <input class="field" type="text" name="q" size="15" maxlength="255" value="">
      <button class="button" type="submit" name="btnG" value=" " title="Search">
      <input type="hidden" name="domains" value="martinfowler.com">
      <input type="hidden" name="sitesearch" value=""> 
      <input type="hidden" name="sitesearch" value="martinfowler.com">
    
  </button></form></div>

<div class="closediv">
<span class="close" title="close"></span>
</div>
</div>

<div class="nav-body">
<div class="topics">
<h2>Topics</h2>

<p><a href="https://martinfowler.com/architecture">Architecture</a></p>

<p><a href="https://refactoring.com/">Refactoring</a></p>

<p><a href="https://martinfowler.com/agile.html">Agile</a></p>

<p><a href="https://martinfowler.com/delivery.html">Delivery</a></p>

<p><a href="https://martinfowler.com/microservices">Microservices</a></p>

<p><a href="https://martinfowler.com/data">Data</a></p>

<p><a href="https://martinfowler.com/testing">Testing</a></p>

<p><a href="https://martinfowler.com/dsl.html">DSL</a></p>
</div>

<div class="about">
<h2>about me</h2>

<p><a href="https://martinfowler.com/aboutMe.html">About</a></p>

<p><a href="https://martinfowler.com/books">Books</a></p>

<p><a href="https://martinfowler.com/faq.html">FAQ</a></p>
</div>

<div class="content">
<h2>content</h2>

<p><a href="https://martinfowler.com/videos.html">Videos</a></p>

<p><a href="https://martinfowler.com/tags">Content Index</a></p>

<p><a href="https://martinfowler.com/articles/eurogames">Board Games</a></p>

<p><a href="https://martinfowler.com/photos">Photography</a></p>
</div>

<div class="tw">
<h2>ThoughtWorks</h2>

<p><a href="https://thoughtworks.com/insights">Insights</a></p>

<p><a href="https://thoughtworks.com/careers">Careers</a></p>

<p><a href="https://thoughtworks.com/products">Products</a></p>
</div>

<div class="feeds">
<h2>follow</h2>

<p><a href="https://www.twitter.com/martinfowler">Twitter</a></p>

<p><a href="https://martinfowler.com/feed.atom">RSS</a></p>
</div>
</div>
</nav>
</nav>
<footer id="page-footer">
<div class="tw-logo">
<a href="http://www.thoughtworks.com/">
<img src="./Micro Frontends_files/tw-white-300.png">
</a>
</div>
<div class="menu-button">
<div class="icon-bars navmenu-button"></div>
</div>
<div class="copyright">
<p>© Martin Fowler | <a href="http://www.thoughtworks.com/privacy-policy">Privacy Policy</a> | <a href="https://martinfowler.com/aboutMe.html#disclosures">Disclosures</a></p>
</div>
</footer>
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-17005812-1', 'auto');
ga('send', 'pageview');
</script>
<script async="" src="./Micro Frontends_files/analytics.js"></script>
<!-- End Google Analytics -->



<script src="./Micro Frontends_files/jquery-1.11.3.min.js" type="text/javascript"></script>

<script src="./Micro Frontends_files/mfcom.js" type="text/javascript"></script>

<script src="./Micro Frontends_files/highlight.pack.js" type="text/javascript"></script>

<script src="./Micro Frontends_files/micro-frontends.js" type="text/javascript"></script>


</body></html>